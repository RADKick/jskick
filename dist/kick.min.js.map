{"version":3,"file":"kick.min.js","sources":["../src/constants.js","../src/parsers.js","../src/observer.js","../src/kick.js","../src/bindings.js","../src/view.js","../src/adapter.js","../src/binders.js","../src/export.js"],"sourcesContent":["export const OPTIONS = [\n  //'prefix',\n  'templateDelimiters',\n  'rootInterface',\n  'preloadData',\n  'handler'\n]\n\nexport const EXTENSIONS = [\n  'binders',\n  'formatters',\n  'components',\n  'adapters'\n]","const PRIMITIVE = 0;\nconst KEYPATH = 1;\nconst TEXT = 0;\nconst BINDING = 1;\n\nconst QUOTED_STR = /^'.*'$|^\".*\"$/;\nconst WHITESPACES = ' \\n\\r\\t'.split('');\n\n// Parser and tokenizer for getting the type and value from a string.\nexport function parseType(string) {\n  let type = PRIMITIVE;\n  let value = string;\n\n  if (QUOTED_STR.test(string)) {\n    value = string.slice(1, -1);\n  } else if (string === \"true\") {\n    value = true;\n  } else if (string === \"false\") {\n    value = false;\n  } else if (string === \"null\") {\n    value = null;\n  } else if (string === \"undefined\") {\n    value = undefined;\n  } else if (!isNaN(string)) {\n    value = Number(string);\n  } else {\n    type = KEYPATH;\n  }\n\n  return { type: type, value: value };\n}\n\n// Template parser and tokenizer for mustache-style text content bindings.\n// Parses the template and returns a set of tokens, separating static portions\n// of text from binding declarations.\nexport function parseTemplate(template, delimiters) {\n  var tokens;\n  let length = template.length;\n  let index = 0;\n  let lastIndex = 0;\n  let open = delimiters[0],\n    close = delimiters[1];\n\n  while (lastIndex < length) {\n    index = template.indexOf(open, lastIndex);\n\n    if (index < 0) {\n      if (tokens) {\n        tokens.push({\n          type: TEXT,\n          value: template.slice(lastIndex)\n        });\n      }\n\n      break;\n    } else {\n      tokens || (tokens = []);\n      if (index > 0 && lastIndex < index) {\n        tokens.push({\n          type: TEXT,\n          value: template.slice(lastIndex, index)\n        });\n      }\n\n      lastIndex = index + open.length;\n      index = template.indexOf(close, lastIndex);\n\n      if (index < 0) {\n        let substring = template.slice(lastIndex - close.length);\n        let lastToken = tokens[tokens.length - 1];\n\n        if (lastToken && lastToken.type === TEXT) {\n          lastToken.value += substring;\n        } else {\n          tokens.push({\n            type: TEXT,\n            value: substring\n          });\n        }\n\n        break;\n      }\n\n      let value = template.slice(lastIndex, index).trim();\n\n      tokens.push({\n        type: BINDING,\n        value: value\n      });\n\n      lastIndex = index + close.length;\n    }\n  }\n\n  return tokens;\n}\n\nexport function parseFnExpr(expr) {\n  function jsNested(statement) {\n    var regex = new RegExp(\"([a-zA-Z0-9_$]+)\\\\((.*)\\\\)\", \"g\");\n    var root = { _: [] };\n\n    if (QUOTED_STR.test(statement)) {\n      root._.push({ k: statement, t: \"l\" });\n      return root;\n    }\n\n    var r = regex.exec(statement);\n    if (!r || r.length < 3) {\n      return root;\n    }\n    var parameters = args(r[2]);\n    var node = { _: [] };\n    parameters.forEach(function(p) {\n      if (p.e) {\n        if (p.e.indexOf(\"(\") == -1) {\n          node._.push({ k: p.e, t: \"p\" });\n        } else {\n          var wrappedNode = jsNested(p.e),\n            k;\n          for (k in wrappedNode) {\n            node._.push(wrappedNode[k][0]);\n          }\n        }\n      } else {\n        //node[p.s] = p.s;\n      }\n    });\n\n    // Assign node to the node's identifier\n    root._.push({ k: r[1], t: 'f', _: node._ });\n    //root._.push(r[1]:node);\n    return root;\n  }\n\n  function args(statement) {\n    statement += \",\"; // so I don't have to handle the \"last, leftover parameter\"\n    var results = [];\n    var chars = statement.split(\"\");\n    var level = 0; // levels of parenthesis, used to track how deep I am in ().\n    var index = 0; // determines which parameter am I currently on.\n    var temp = \"\", match = '', temp2 = '';\n    chars.forEach(function(char) {\n      switch (true) {\n        case char === \"'\":\n        case char === '\"':\n          if (match.length && match === char) {\n            temp += match + temp2 + match;\n            results[index] = { s: temp2 };\n            match = temp2 = '';\n            //level--;\n            //temp = '';\n            index++;\n          } else {\n            match = char;\n            //level++;\n          }\n          //level++;\n          break;\n        case !match.length && WHITESPACES.indexOf(char) !== -1:\n          break;\n        case !match.length && char === '(':\n          temp += char;\n          level++;\n          break;\n        case !match.length && char === ')':\n          temp += char;\n          level--;\n          break;\n        case !match.length && char === ',':\n          // if the comma is between a set of parenthesis, ignore.\n          if (level !== 0) {\n            temp += char;\n          }\n          // if the comma is external, split the string.\n          else {\n            results[index] = { e: temp };\n            temp = '';\n            index++;\n          }\n          break;\n        default:\n          if (match.length) {\n            temp2 += char;\n          } else {\n            temp += char;\n          }\n          break;\n      }\n    });\n    return results;\n  }\n\n  //return if we were able to parse functions otherwise it will be null\n  return jsNested(expr)._[0] || null;\n}\n","\n// Check if a value is an object than can be observed.\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null\n}\n\n// Error thrower.\nfunction error(message) {\n  throw new Error('[Observer] ' + message)\n}\n\nvar adapters\nvar interfaces\nvar rootInterface\n\n// Constructs a new keypath observer and kicks things off.\nfunction Observer(obj, keypath, callback) {\n  this.keypath = keypath\n  this.callback = callback\n  this.objectPath = []\n  this.parse()\n  this.obj = this.getRootObject(obj)\n\n  if (isObject(this.target = this.realize())) {\n    this.set(true, this.key, this.target, this.callback)\n  }\n}\n\nObserver.updateOptions = function(options) {\n  adapters = options.adapters\n  interfaces = Object.keys(adapters)\n  rootInterface = options.rootInterface\n}\n\n// Tokenizes the provided keypath string into interface + path tokens for the\n// observer to work with.\nObserver.tokenize = function(keypath, root) {\n  var tokens = []\n  var current = {i: root, path: ''}\n  var index, chr\n\n  for (index = 0; index < keypath.length; index++) {\n    chr = keypath.charAt(index)\n\n    if (!!~interfaces.indexOf(chr)) {\n      tokens.push(current)\n      current = {i: chr, path: ''}\n    } else {\n      current.path += chr\n    }\n  }\n\n  tokens.push(current)\n  return tokens\n}\n\n// Parses the keypath using the interfaces defined on the view. Sets variables\n// for the tokenized keypath as well as the end key.\nObserver.prototype.parse = function() {\n  var path, root\n\n  if (!interfaces.length) {\n    error('Must define at least one adapter interface.')\n  }\n\n  if (!!~interfaces.indexOf(this.keypath[0])) {\n    root = this.keypath[0]\n    path = this.keypath.substr(1)\n  } else {\n    root = rootInterface\n    path = this.keypath\n  }\n\n  this.tokens = Observer.tokenize(path, root)\n  this.key = this.tokens.pop()\n}\n\n// Realizes the full keypath, attaching observers for every key and correcting\n// old observers to any changed objects in the keypath.\nObserver.prototype.realize = function() {\n  var current = this.obj\n  var unreached = -1\n  var prev\n  var token\n\n  for (let index = 0; index < this.tokens.length; index++) {\n    token = this.tokens[index]\n    if (isObject(current)) {\n      if (typeof this.objectPath[index] !== 'undefined') {\n        if (current !== (prev = this.objectPath[index])) {\n          this.set(false, token, prev, this)\n          this.set(true, token, current, this)\n          this.objectPath[index] = current\n        }\n      } else {\n        this.set(true, token, current, this)\n        this.objectPath[index] = current\n      }\n\n      current = this.get(token, current)\n    } else {\n      if (unreached === -1) {\n        unreached = index\n      }\n\n      if (prev = this.objectPath[index]) {\n        this.set(false, token, prev, this)\n      }\n    }\n  }\n\n  if (unreached !== -1) {\n    this.objectPath.splice(unreached)\n  }\n\n  return current\n}\n\n// Updates the keypath. This is called when any intermediary key is changed.\nObserver.prototype.sync = function() {\n  var next, oldValue, newValue\n\n  if ((next = this.realize()) !== this.target) {\n    if (isObject(this.target)) {\n      this.set(false, this.key, this.target, this.callback)\n    }\n\n    if (isObject(next)) {\n      this.set(true, this.key, next, this.callback)\n    }\n\n    oldValue = this.value()\n    this.target = next\n    newValue = this.value()\n    if (newValue !== oldValue || newValue instanceof Function) this.callback.sync()\n  } else if (next instanceof Array) {\n    this.callback.sync()\n  }\n}\n\n// Reads the current end value of the observed keypath. Returns undefined if\n// the full keypath is unreachable.\nObserver.prototype.value = function() {\n  if (isObject(this.target)) {\n    return this.get(this.key, this.target)\n  }\n}\n\n// Sets the current end value of the observed keypath. Calling setValue when\n// the full keypath is unreachable is a no-op.\nObserver.prototype.setValue = function(value) {\n  if (isObject(this.target)) {\n    adapters[this.key.i].set(this.target, this.key.path, value)\n  }\n}\n\n// Gets the provided key on an object.\nObserver.prototype.get = function(key, obj) {\n  return adapters[key.i].get(obj, key.path)\n}\n\n// Observes or unobserves a callback on the object using the provided key.\nObserver.prototype.set = function(active, key, obj, callback) {\n  var action = active ? 'observe' : 'unobserve'\n  adapters[key.i][action](obj, key.path, callback)\n}\n\n\n// Unobserves the entire keypath.\nObserver.prototype.unobserve = function() {\n  var obj\n  var token\n\n  for (let index = 0; index < this.tokens.length; index++) {\n    token = this.tokens[index]\n    if (obj = this.objectPath[index]) {\n      this.set(false, token, obj, this)\n    }\n  }\n\n  if (isObject(this.target)) {\n    this.set(false, this.key, this.target, this.callback)\n  }\n}\n// traverse the scope chain to find the scope which has the root property\n// if the property is not found in chain, returns the root scope\nObserver.prototype.getRootObject = function (obj) {\n  var rootProp, current;\n  if (!obj.$parent) {\n    return obj;\n  }\n\n  if (this.tokens.length) {\n    rootProp = this.tokens[0].path\n  } else {\n    rootProp = this.key.path\n  }\n\n  current = obj;\n  while (current.$parent && (current[rootProp] === undefined)) {\n    current = current.$parent\n  }\n\n  return current;\n}\n\nexport default Observer\n","import {EXTENSIONS} from './constants'\nimport {parseTemplate, parseType} from './parsers'\n\nconst kick = {\n  // Global binders.\n  binders: {},\n\n  // Global formatters.\n  formatters: {},\n\n  // Global components.\n  components: {},\n\n  // Global sightglass adapters.\n  adapters: {},\n\n  /*\n  // Default attribute prefix.\n  _prefix: 'rv',\n\n  _fullPrefix: 'rv-',\n\n  /* get prefix () {\n    return this._prefix\n  },\n\n  set prefix (value) {\n    this._prefix = value\n    this._fullPrefix = value + '-'\n  }, */\n\n  parseTemplate: parseTemplate,\n\n  parseType: parseType,\n\n  // Default template delimiters.\n  templateDelimiters: ['{{', '}}'],\n\n  // Binder shortcuts - extend it if you want to have your own\n  // else if(nodeName === '?') {nodeName = 'if';}\n\n  binderMap: {\n    '^': '^click',\n    '^^': '^dblclick',\n    '^_': '^contextmenu',\n    '@': '@value',\n    '@x': '@checked',\n    ':' : ':text',\n    '::' : ':html',\n    '$' : ':html',\n    '-': ':hide',\n    '+': ':show',\n    '~': ':disabled',\n    '~~': ':enabled'\n    },\n    // was starBinder in rivetsjs, in kickjs *(star) is used for binding so changing it to varBinder is an variable binder\n    varBinderMap: {\n      '.&': ':class-&',\n      '..&': ':style-&',\n      '::&': ':attr-&',\n    },\n  // Default sightglass root interface.\n  rootInterface: '.',\n\n  // Preload data by default.\n  preloadData: true,\n\n  // Default event handler.\n  handler: function(context, ev, binding) {\n    //changing the order of returns as well as passed arguments first then $event\n    //todo document this breakig change\n    const processedArgs = binding.parseFormatterArguments(binding.fnArgs, 0);\n    this.call(context, ...[...processedArgs, binding.view.models, ev])\n  },\n\n  // Sets the attribute on the element. If no binder above is matched it will fall\n  // back to using this binder.\n  fallbackBinder: function(el, value) {\n    if (value != null) {\n      el.setAttribute(this.type, value)\n    } else {\n      el.removeAttribute(this.type)\n    }\n  },\n\n  // Merges an object literal into the corresponding global options.\n  configure: function(options) {\n    if (!options) {\n      return\n    }\n    Object.keys(options).forEach(option => {\n      let value = options[option]\n\n      if (EXTENSIONS.indexOf(option) > -1) {\n        Object.keys(value).forEach(key => {\n          this[option][key] = value[key]\n        })\n      } else {\n        this[option] = value\n      }\n    })\n  },\n\n  router:{}\n}\n\nexport default kick\n","import { parseType, parseFnExpr } from \"./parsers\";\nimport Observer from \"./observer\";\n\nfunction getInputValue(el) {\n  let results = [];\n  if (el.type === \"checkbox\") {\n    return el.checked;\n  } else if (el.type === \"select-multiple\") {\n    el.options.forEach(option => {\n      if (option.selected) {\n        results.push(option.value);\n      }\n    });\n\n    return results;\n  } else {\n    return el.value;\n  }\n}\n\nconst FORMATTER_ARGS = /[^\\s']+|'([^']|'[^\\s])*'|\"([^\"]|\"[^\\s])*\"/g;\nconst FORMATTER_SPLIT = /\\s+/;\nconst FN_CHECK = /\\(.*\\)/;\n\n// A single binding between a model attribute and a DOM element.\nexport class Binding {\n  // All information about the binding is passed into the constructor; the\n  // containing view, the DOM node, the type of binding, the model object and the\n  // keypath at which to listen for changes.\n  constructor(view, el, type, keypath, binder, arg, formatters) {\n    this.view = view;\n    this.el = el;\n    this.type = type;\n    this.keypath = keypath;\n    this.binder = binder;\n    this.arg = arg;\n    this.formatters = formatters;\n    this.formatterObservers = {};\n    this.model = undefined;\n    //newly added for fn args but not sure if this is the right way\n    this.fnArgs = [];\n    this.locked = false;\n    this.subscribers = [];\n  }\n\n  // Observes the object keypath\n  observe(obj, keypath) {\n    return new Observer(obj, keypath, this);\n  }\n\n  parseTarget() {\n    if (this.keypath) {\n      let token = parseType(this.keypath);\n\n      if (token.type === 0) {\n        this.value = token.value;\n      } else {\n        if (FN_CHECK.test(this.keypath)) {\n          let fnExpr = parseFnExpr(this.keypath);\n          if (fnExpr) {\n            this.keypath = fnExpr.k;\n            this.fnArgs = fnExpr._.map(x => x.k);\n            //let fnArgs = fnExpr._.map(x => x.k)\n            //this.fnArgs = this.parseFormatterArguments(fnArgs, 0)\n          }\n        }\n        this.observer = this.observe(this.view.models, this.keypath);\n        this.model = this.observer.target;\n      }\n    } else {\n      this.value = undefined;\n    }\n  }\n\n  parseFormatterArguments(args, formatterIndex) {\n    return args.map(parseType).map(({ type, value }, ai) => {\n      if (type === 0) {\n        return value;\n      } else {\n        if (!this.formatterObservers[formatterIndex]) {\n          this.formatterObservers[formatterIndex] = {};\n        }\n\n        let observer = this.formatterObservers[formatterIndex][ai];\n\n        if (!observer) {\n          observer = this.observe(this.view.models, value);\n          this.formatterObservers[formatterIndex][ai] = observer;\n        }\n\n        return observer.value();\n      }\n    });\n  }\n\n  // Applies all the current formatters to the supplied value and returns the\n  // formatted value.\n  formattedValue(value) {\n    return this.formatters.reduce((result, declaration, index) => {\n      let args = declaration.match(FORMATTER_ARGS);\n      let id = args.shift();\n      let formatter = this.view.options.formatters[id];\n\n      const processedArgs = this.parseFormatterArguments(args, index);\n\n      if (formatter && formatter.read instanceof Function) {\n        result = formatter.read(result, ...processedArgs);\n      } else if (formatter instanceof Function) {\n        result = formatter(result, ...processedArgs);\n      }\n      return result;\n    }, value);\n  }\n\n  // Returns an event handler for the binding around the supplied function.\n  eventHandler(fn) {\n    let binding = this;\n    let handler = binding.view.options.handler;\n\n    return function(ev) {\n      handler.call(fn, this, ev, binding);\n    };\n  }\n\n  // Sets the value for the binding. This Basically just runs the binding routine\n  // with the supplied value formatted.\n  set(value) {\n    if(this.locked) { return; }\n    if (value instanceof Function && !this.binder.function) {\n      //todo update docs, probably a breaking change\n      const processedArgs = this.parseFormatterArguments(this.fnArgs, 0);\n      value = this.formattedValue(\n        value.call(this.model, ...[...processedArgs, this.view.models])\n      );\n      //value = this.formattedValue(value.call(this.model))\n    } else {\n      value = this.formattedValue(value);\n    }\n\n    let routineFn = this.binder.routine || this.binder;\n\n    if (routineFn instanceof Function) {\n      this.locked = true;\n      routineFn.call(this, this.el, value);\n      this.callSubscribers(value);\n      this.locked = false;\n    }\n  }\n\n  // Syncs up the view binding with the model.\n  sync() {\n    if (this.observer) {\n      this.model = this.observer.target;\n      this.set(this.observer.value());\n    } else {\n      this.set(this.value);\n    }\n  }\n\n  // Publishes the value currently set on the input element back to the model.\n  publish() {\n    if (this.observer) {\n      var value = this.formatters.reduceRight((result, declaration, index) => {\n        const args = declaration.split(FORMATTER_SPLIT);\n        const id = args.shift();\n        const formatter = this.view.options.formatters[id];\n        const processedArgs = this.parseFormatterArguments(args, index);\n\n        if (formatter && formatter.publish) {\n          result = formatter.publish(result, ...processedArgs);\n        }\n        return result;\n      }, this.getValue(this.el));\n\n      this.observer.setValue(value);\n    }\n  }\n\n  // Subscribes to the model for changes at the specified keypath. Bi-directional\n  // routines will also listen for changes on the element to propagate them back\n  // to the model.\n  bind() {\n    this.parseTarget();\n\n    if (this.binder.hasOwnProperty(\"bind\")) {\n      this.binder.bind.call(this, this.el);\n    }\n\n    if (this.view.options.preloadData) {\n      this.sync();\n    }\n  }\n\n  // Unsubscribes from the model and the element.\n  unbind() {\n    if (this.binder.unbind) {\n      this.binder.unbind.call(this, this.el);\n    }\n\n    if (this.observer) {\n      this.observer.unobserve();\n    }\n\n    Object.keys(this.formatterObservers).forEach(fi => {\n      let args = this.formatterObservers[fi];\n\n      Object.keys(args).forEach(ai => {\n        args[ai].unobserve();\n      });\n    });\n\n    this.formatterObservers = {};\n  }\n\n  // Updates the binding's model from what is currently set on the view. Unbinds\n  // the old model first and then re-binds with the new model.\n  update(models = {}) {\n    if (this.observer) {\n      this.model = this.observer.target;\n    }\n\n    if (this.binder.update) {\n      this.binder.update.call(this, models);\n    }\n  }\n\n  // Returns elements value\n  getValue(el) {\n    if (this.binder && this.binder.getValue) {\n      return this.binder.getValue.call(this, el);\n    } else {\n      return getInputValue(el);\n    }\n  }\n\n  // Subscribe to the value changes\n  subscribe(listener) {\n    var index = this.subscribers.push(listener) -1;\n\n    // Provide handle back for removal of listener\n    return {\n      remove: function() {\n        delete this.subscribers[index];\n      }\n    };\n  }\n\n  // Call the subscribers\n  callSubscribers(value){\n      // Cycle through subscribers queue, fire!\n      this.subscribers.forEach(function(item) {\n        item(value);\n    });      \n  }\n\n  // Returns the fellow binding of a given type on same element\n  fellow(type){\n    return this.view.bindings.find((x)=> {return x.el === this.el && x.type === type;});\n  }\n}\n","import kick from './kick'\nimport {Binding} from './bindings'\nimport {parseTemplate} from './parsers'\n//import ComponentBinding from './components'\n\nconst textBinder = {\n  routine: (node, value) => {\n    node.data = (value != null) ? value : ''\n  }\n}\n\nconst DECLARATION_SPLIT = /((?:'[^']*')*(?:(?:[^\\|']*(?:'[^']*')+[^\\|']*)+|[^\\|]+))|^$/g\nconst ESCAPE_BINDER = /[.*+?^${}()|[\\]\\\\]/g\nconst ESCAPE_BINDER_WITH = '\\\\$&'\nconst binderPrefixes = '@:^.-+?!*#$~'.split('')\n\n\nconst parseNode = (view, node) => {\n  let block = false\n\n  if (node.nodeType === 3) {\n    let tokens = parseTemplate(node.data, kick.templateDelimiters)\n\n    if (tokens) {\n      for (let i = 0; i < tokens.length; i++) {\n        let token = tokens[i]\n        let text = document.createTextNode(token.value)\n        node.parentNode.insertBefore(text, node)\n\n        if (token.type === 1) {\n          view.buildBinding(text, null, token.value, textBinder, null)\n        }\n      }\n\n      node.parentNode.removeChild(node)\n    }\n    block = true\n  } else if (node.nodeType === 1) {\n    block = view.traverse(node)\n  }\n\n  if (!block) {\n    for (let i = 0; i < node.childNodes.length; i++) {\n      parseNode(view, node.childNodes[i]);\n    }\n  }\n}\n\nconst bindingComparator = (a, b) => {\n  let aPriority = a.binder ? (a.binder.priority || 0) : 0\n  let bPriority = b.binder ? (b.binder.priority || 0) : 0\n  return bPriority - aPriority\n}\n\nconst trimStr = (str) => {\n  return str.trim()\n}\n\n// A collection of bindings built from a set of parent nodes.\nexport default class View {\n  // The DOM elements and the model objects for binding are passed into the\n  // constructor along with any local options that should be used throughout the\n  // context of the view and it's bindings.\n  constructor(els, models, options) {\n    if (els.jquery || els instanceof Array) {\n      this.els = els\n    } else {\n      this.els = [els]\n    }\n\n    this.models = models\n    this.options = options\n\n    this.build()\n  }\n\n\n  buildBinding(node, type, declaration, binder, arg) {\n    let pipes = declaration.match(DECLARATION_SPLIT).map(trimStr)\n\n    let keypath = pipes.shift()\n\n    if(arg === '' && type === '*'){\n      //resolve for in expression, useful for case sensitive members e.g. myItem in items\n      const forRE = new RegExp(/^(.+)\\s+in\\s+(.[^|\\s]+)(.*)$/gm);\n      let forExp = forRE.exec(keypath);\n      // console.log(forExp)\n      if(forExp && forExp.length > 2){\n        arg = forExp[1] || arg\n        keypath = forExp[2] || keypath\n      }\n      // console.log(forExp[3].split('|'))\n    }\n\n    this.bindings.push(new Binding(this, node, type, keypath, binder, arg, pipes))\n  }\n\n  // Parses the DOM tree and builds `Binding` instances for every matched\n  // binding declaration.\n  build() {\n    this.bindings = []\n\n    let elements = this.els, i, len;\n    for (i = 0, len = elements.length; i < len; i++) {\n      parseNode(this, elements[i])\n    }\n\n    this.bindings.sort(bindingComparator)\n  }\n\n  traverse(node) {\n    // let bindingPrefix = kick._fullPrefix\n    let block = node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE'\n    let attributes = node.attributes\n    let bindInfos = []\n    let varBinders = this.options.varBinders\n    let mappedBinder\n    var binderType, binder, identifier, arg\n\n    for (let i = 0, len = attributes.length; i < len; i++) {\n      let attribute = attributes[i]\n      // if (attribute.name.indexOf(bindingPrefix) === 0) {\n      if (this.startWithBinder(attribute.name)) {\n          // binderType = attribute.name.slice(bindingPrefix.length);\n          mappedBinder = kick.binderMap[attribute.name];\n          binderType = mappedBinder || attribute.name;\n\n        // type = attribute.name.slice(bindingPrefix.length)\n        binder = this.options.binders[binderType]\n        arg = undefined\n\n        if (!binder) {\n          for (let k = 0; k < varBinders.length; k++) {\n            identifier = varBinders[k]\n            if (binderType.slice(0, identifier.length - 1) === identifier.slice(0, -1)) {\n              binder = this.options.binders[identifier]\n              arg = binderType.slice(identifier.length - 1)\n              break\n            }\n          }\n        }\n\n        if (!binder) {\n          binder = kick.fallbackBinder\n        }\n\n        if (binder.block) {\n          this.buildBinding(node, binderType, attribute.value, binder, arg)\n          node.removeAttribute(attribute.name)\n          return true;\n        }\n\n        bindInfos.push({attr: attribute, binder: binder, type: binderType, arg: arg})\n      }\n    }\n\n    for (let i = 0; i < bindInfos.length; i++) {\n      let bindInfo = bindInfos[i]\n      this.buildBinding(node, bindInfo.type, bindInfo.attr.value, bindInfo.binder, bindInfo.arg)\n      node.removeAttribute(bindInfo.attr.name)\n    }\n\n    if (kick.components[binderType] && !node._bound) {\n       this.bindings.push(new ComponentBinding(this, node, binderType));\n       block = true;\n    }\n\n    return block\n  }\n\n  // Binds all of the current bindings for this view.\n  bind() {\n    this.bindings.forEach(binding => {\n      binding.bind()\n    })\n  }\n\n  // Unbinds all of the current bindings for this view.\n  unbind() {\n    this.bindings.forEach(binding => {\n      binding.unbind()\n    })\n  }\n\n  // Syncs up the view with the model by running the routines on all bindings.\n  sync() {\n    this.bindings.forEach(binding => {\n      binding.sync()\n    })\n  }\n\n  // Publishes the input values from the view back to the model (reverse sync).\n  publish() {\n    this.bindings.forEach(binding => {\n      if (binding.binder && binding.binder.publishes) {\n        binding.publish()\n      }\n    })\n  }\n\n  // Updates the view's models along with any affected bindings.\n  update(models = {}) {\n    Object.keys(models).forEach(key => {\n      this.models[key] = models[key]\n    })\n\n    this.bindings.forEach(binding => {\n      if (binding.update) {\n        binding.update(models)\n      }\n    })\n  }\n\n  // move it to utils\n  startWithBinder(name) {\n    const prefix = name.substr(0, 1)\n    return binderPrefixes.some((pre) => pre === prefix)\n  }\n}\n","// The default `.` adapter that comes with kick.js. Allows subscribing to\n// properties on plain objects, implemented in ES5 natives using\n// `Object.defineProperty`.\n\nconst ARRAY_METHODS = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'sort',\n  'reverse',\n  'splice'\n]\n\nconst adapter = {\n  counter: 0,\n  weakmap: {},\n\n  weakReference: function(obj) {\n    if (!obj.hasOwnProperty('__rv')) {\n      let id = this.counter++\n\n      Object.defineProperty(obj, '__rv', {\n        value: id\n      })\n    }\n\n    if (!this.weakmap[obj.__rv]) {\n      this.weakmap[obj.__rv] = {\n        callbacks: {}\n      }\n    }\n\n    return this.weakmap[obj.__rv]\n  },\n\n  cleanupWeakReference: function(ref, id) {\n    if (!Object.keys(ref.callbacks).length) {\n      if (!(ref.pointers && Object.keys(ref.pointers).length)) {\n        delete this.weakmap[id]\n      }\n    }\n  },\n\n  stubFunction: function(obj, fn) {\n    let original = obj[fn]\n    let map = this.weakReference(obj)\n    let weakmap = this.weakmap\n\n    obj[fn] = (...args) => {\n      let response = original.apply(obj, args)\n\n      Object.keys(map.pointers).forEach(r => {\n        let k = map.pointers[r]\n\n        if (weakmap[r]) {\n          if (weakmap[r].callbacks[k] instanceof Array) {\n            weakmap[r].callbacks[k].forEach(callback => {\n              callback.sync()\n            })\n          }\n        }\n      })\n\n      return response\n    }\n  },\n\n  observeMutations: function(obj, ref, keypath) {\n    if (obj instanceof Array) {\n      let map = this.weakReference(obj)\n\n      if (!map.pointers) {\n        map.pointers = {}\n\n        ARRAY_METHODS.forEach(fn => {\n          this.stubFunction(obj, fn)\n        })\n      }\n\n      if (!map.pointers[ref]) {\n        map.pointers[ref] = []\n      }\n\n      if (map.pointers[ref].indexOf(keypath) === -1) {\n        map.pointers[ref].push(keypath)\n      }\n    }\n  },\n\n  unobserveMutations: function(obj, ref, keypath) {\n    if ((obj instanceof Array) && (obj.__rv != null)) {\n      let map = this.weakmap[obj.__rv]\n\n      if (map) {\n        let pointers = map.pointers[ref]\n\n        if (pointers) {\n          let idx = pointers.indexOf(keypath)\n\n          if (idx > -1) {\n            pointers.splice(idx, 1)\n          }\n\n          if (!pointers.length) {\n            delete map.pointers[ref]\n          }\n\n          this.cleanupWeakReference(map, obj.__rv)\n        }\n      }\n    }\n  },\n\n  observe: function(obj, keypath, callback) {\n    var value;\n    let callbacks = this.weakReference(obj).callbacks\n\n    if (!callbacks[keypath]) {\n      callbacks[keypath] = []\n      let desc = Object.getOwnPropertyDescriptor(obj, keypath)\n\n      if (!desc || !(desc.get || desc.set || !desc.configurable)) {\n        value = obj[keypath]\n\n        Object.defineProperty(obj, keypath, {\n          enumerable: true,\n\n          get: () => {\n            return value\n          },\n\n          set: newValue => {\n            if (newValue !== value) {\n              this.unobserveMutations(value, obj.__rv, keypath)\n              value = newValue\n              let map = this.weakmap[obj.__rv]\n\n              if (map) {\n                let callbacks = map.callbacks[keypath]\n\n                if (callbacks) {\n                  callbacks.forEach(cb => {\n                      cb.sync()\n                  })\n                }\n\n                this.observeMutations(newValue, obj.__rv, keypath)\n              }\n            }\n          }\n        })\n      }\n    }\n\n    if (callbacks[keypath].indexOf(callback) === -1) {\n      callbacks[keypath].push(callback)\n    }\n\n    this.observeMutations(obj[keypath], obj.__rv, keypath)\n  },\n\n  unobserve: function(obj, keypath, callback) {\n    let map = this.weakmap[obj.__rv]\n\n    if (map) {\n      let callbacks = map.callbacks[keypath]\n\n      if (callbacks) {\n        let idx = callbacks.indexOf(callback)\n\n        if (idx > -1) {\n          callbacks.splice(idx, 1)\n\n          if (!callbacks.length) {\n            delete map.callbacks[keypath]\n            this.unobserveMutations(obj[keypath], obj.__rv, keypath)\n          }\n        }\n\n        this.cleanupWeakReference(map, obj.__rv)\n      }\n    }\n  },\n\n  get: function(obj, keypath) {\n    return obj[keypath]\n  },\n\n  set: (obj, keypath, value) => {\n    obj[keypath] = value\n  }\n}\n\nexport default adapter\n","import View from './view'\nimport kick from './kick';\n\nconst getString = (value) => {\n  return value != null ? value.toString() : undefined\n}\n\nconst times = (n, cb) => {\n  for (let i = 0; i < n; i++) cb()\n}\n\nfunction createView(binding, data, anchorEl) {\n  let template = binding.el.cloneNode(true)\n  let view = new View(template, data, binding.view.options)\n  view.bind()\n  binding.marker.parentNode.insertBefore(template, anchorEl)\n  return view\n}\n\nconst binders = {\n  // Binds an event handler on the element.\n  '^&': {\n    function: true,\n    priority: 1000,\n\n    unbind: function(el) {\n      if (this.handler) {\n        el.removeEventListener(this.arg, this.handler)\n      }\n    },\n\n    routine: function(el, value) {\n      if (this.handler) {\n        el.removeEventListener(this.arg, this.handler)\n      }\n\n      this.handler = this.eventHandler(value)\n      el.addEventListener(this.arg, this.handler)\n    }\n  },\n\n  // for $item Appends bound instances of the element in place for item in the array.\n  '*&': {\n    block: true,\n\n    priority: 4000,\n\n    bind: function(el) {\n      if (!this.marker) {\n        this.marker = document.createComment(` kick: ${this.type} `)\n        this.iterated = []\n\n        el.parentNode.insertBefore(this.marker, el)\n        el.parentNode.removeChild(el)\n      } else {\n        this.iterated.forEach(view => {\n          view.bind()\n        })\n      }\n    },\n\n    unbind: function(el) {\n      if (this.iterated) {\n        this.iterated.forEach(view => {\n          view.unbind()\n        })\n      }\n    },\n\n    routine: function(el, collection) {\n      let modelName = this.arg || '$item'\n      collection = collection || []\n      let indexProp = el.getAttribute('#index') || el.getAttribute('index-property') || '$index'\n\n      collection.forEach((model, index) => {\n        let data = {$parent: this.view.models}\n        data[indexProp] = index\n        data[modelName] = model\n        let view = this.iterated[index]\n\n        if (!view) {\n\n          let previous = this.marker\n\n          if (this.iterated.length) {\n            previous = this.iterated[this.iterated.length - 1].els[0]\n          }\n\n          view = createView(this, data, previous.nextSibling)\n          this.iterated.push(view)\n        } else {\n          if (view.models[modelName] !== model) {\n            // search for a view that matches the model\n            let matchIndex, nextView\n            for (let nextIndex = index + 1; nextIndex < this.iterated.length; nextIndex++) {\n              nextView = this.iterated[nextIndex]\n              if (nextView.models[modelName] === model) {\n                matchIndex = nextIndex\n                break\n              }\n            }\n            if (matchIndex !== undefined) {\n              // model is in other position\n              // todo: consider avoiding the splice here by setting a flag\n              // profile performance before implementing such change\n              this.iterated.splice(matchIndex, 1)\n              this.marker.parentNode.insertBefore(nextView.els[0], view.els[0])\n              nextView.models[indexProp] = index\n            } else {\n              //new model\n              nextView = createView(this, data, view.els[0])\n            }\n            this.iterated.splice(index, 0, nextView)\n          } else {\n            view.models[indexProp] = index\n          }\n        }\n      })\n\n      if (this.iterated.length > collection.length) {\n        times(this.iterated.length - collection.length, () => {\n          let view = this.iterated.pop()\n          view.unbind()\n          this.marker.parentNode.removeChild(view.els[0])\n        })\n      }\n\n      if (el.nodeName === 'OPTION') {\n        this.view.bindings.forEach(binding => {\n          if (binding.el === this.marker.parentNode && binding.type === 'value') {\n            binding.sync()\n          }\n        })\n      }\n    },\n\n    update: function(models) {\n      let data = {}\n\n      //todo: add test and fix if necessary\n\n      Object.keys(models).forEach(key => {\n        if (key !== this.arg) {\n          data[key] = models[key]\n        }\n      })\n\n      this.iterated.forEach(view => {\n        view.update(data)\n      })\n    }\n  },\n\n  // Order of ..& should be before .& otherwise match will trigger shorter length first\n  '..&': function(el, value) {\n    const propertyName = this.arg;\n    if (value) {\n      el.style[propertyName] = value;\n    } else {\n      el.style[propertyName] = '';\n    }\n  },\n\n  // Adds or removes the class from the element when value is true or false.\n  '.&': function(el, value) {\n    let elClass = ` ${el.className} `\n\n    if (!value === (elClass.indexOf(` ${this.arg} `) > -1)) {\n      if (value) {\n        el.className = `${el.className} ${this.arg}`\n      } else {\n        el.className = elClass.replace(` ${this.arg} `, ' ').trim()\n      }\n    }\n  },\n\n  // Sets the element's text value.\n  ':text': (el, value) => {\n    el.textContent = value != null ? value : ''\n  },\n\n  // Sets the element's HTML content.\n  ':html': (el, value) => {\n    el.innerHTML = value != null ? value : ''\n  },\n\n  // Shows the element when value is true.\n  ':show': (el, value) => {\n    el.style.display = value ? '' : 'none'\n  },\n\n  // Hides the element when value is true (negated version of `show` binder).\n  ':hide': (el, value) => {\n    el.style.display = value ? 'none' : ''\n  },\n\n  // Enables the element when value is true.\n  ':enabled': (el, value) => {\n    el.disabled = !value\n  },\n\n  // Disables the element when value is true (negated version of `enabled` binder).\n  ':disabled': (el, value) => {\n    el.disabled = !!value\n  },\n\n  // Checks a checkbox or radio input when the value is true. Also sets the model\n  // property when the input is checked or unchecked (two-way binder).\n  '@checked': {\n    publishes: true,\n    priority: 2000,\n\n    bind: function(el) {\n      var self = this;\n      if (!this.callback) {\n        this.callback = function () {\n          self.publish();\n        }\n      }\n      el.addEventListener('change', this.callback)\n    },\n\n    unbind: function(el) {\n      el.removeEventListener('change', this.callback)\n    },\n\n    routine: function(el, value) {\n      if (el.type === 'radio') {\n        el.checked = getString(el.value) === getString(value)\n      } else {\n        el.checked = !!value\n      }\n    }\n  },\n\n  // Sets the element's value. Also sets the model property when the input changes\n  // (two-way binder).\n  '@value': {\n    publishes: true,\n    priority: 3000,\n\n    bind: function(el) {\n      this.isRadio = el.tagName === 'INPUT' && el.type === 'radio';\n      if (!this.isRadio) {\n        this.event = el.getAttribute('event-name') || (el.tagName === 'SELECT' ? 'change' : 'input')\n\n        var self = this;\n        if (!this.callback) {\n          this.callback = function () {\n            self.publish();\n          }\n        }\n\n        el.addEventListener(this.event, this.callback)\n      }\n    },\n\n    unbind: function(el) {\n      if (!this.isRadio) {\n        el.removeEventListener(this.event, this.callback)\n      }\n    },\n\n    routine: function(el, value) {\n      if (this.isRadio) {\n        el.setAttribute('value', value)\n      } else {\n        if (el.type === 'select-multiple') {\n          if (value instanceof Array) {\n            for (let i = 0; i < el.length; i++) {\n              let option = el[i];\n              option.selected = value.indexOf(option.value) > -1\n            }\n          }\n        } else if (getString(value) !== getString(el.value)) {\n          el.value = value != null ? value : ''\n        }\n      }\n    }\n  },\n\n  // Inserts and binds the element and it's child nodes into the DOM when true.\n  '?': {\n    block: true,\n    priority: 4000,\n\n    bind: function(el) {\n      if (!this.marker) {\n        this.marker = document.createComment(' kick: ' + this.type + ' ' + this.keypath + ' ');\n        this.attached = false\n\n        el.parentNode.insertBefore(this.marker, el)\n        el.parentNode.removeChild(el)\n      } else if (this.bound === false && this.nested) {\n        this.nested.bind()\n      }\n      this.bound = true\n    },\n\n    unbind: function() {\n      if (this.nested) {\n        this.nested.unbind()\n        this.bound = false\n      }\n    },\n\n    routine: function(el, value) {\n      if (!!value !== this.attached) {\n        if (value) {\n\n          if (!this.nested) {\n            this.nested = new View(el, this.view.models, this.view.options)\n            this.nested.bind()\n          }\n\n          this.marker.parentNode.insertBefore(el, this.marker.nextSibling)\n          this.attached = true\n        } else {\n          el.parentNode.removeChild(el)\n          this.attached = false\n        }\n      }\n    },\n\n    update: function(models) {\n      if (this.nested) {\n        this.nested.update(models)\n      }\n    }\n  },\n  '::&': function(el, value) {\n    if (value != null) {\n      el.setAttribute(this.arg, value)\n    } else {\n      el.removeAttribute(this.arg)\n    }\n  }\n}\n\nexport default binders\n","import kick from './kick'\nimport View from './view'\nimport {OPTIONS, EXTENSIONS} from './constants'\nimport adapter from './adapter'\nimport binders from './binders'\nimport Observer from './observer'\n//import router from './router'\n//import components from './components'\n\n// Returns the public interface.\nkick.binders = binders\n//kick.components = components\nkick.adapters['.'] = adapter\n//kick.router = router\n\n// Binds some data to a template / element. Returns a kick.View instance.\nkick.bind = (elm, models, options) => {\n  // if element then return itself\n  elm = elm || '[kick-app]';\n  let el = (elm.nodeType && elm.nodeType > 0) ? elm : document.querySelector(elm);\n\n  let viewOptions = {}\n  models = models || {}\n  options = options || {}\n\n  EXTENSIONS.forEach(extensionType => {\n    viewOptions[extensionType] = Object.create(null)\n\n    if (options[extensionType]) {\n      Object.keys(options[extensionType]).forEach(key => {\n        viewOptions[extensionType][key] = options[extensionType][key]\n      })\n    }\n\n    Object.keys(kick[extensionType]).forEach(key => {\n      if (!viewOptions[extensionType][key]) {\n        viewOptions[extensionType][key] = kick[extensionType][key]\n      }\n    })\n  })\n\n  OPTIONS.forEach(option => {\n    let value = options[option]\n    viewOptions[option] = value != null ? value : kick[option]\n  })\n\n  viewOptions.varBinders = Object.keys(viewOptions.binders).filter(function (key) {\n    return key.indexOf('&') > 0\n  })\n\n  Observer.updateOptions(viewOptions)\n\n  let view = new View(el, models, viewOptions)\n  view.bind()\n  return view\n}\n\n// Initializes a new instance of a component on the specified element and\n// returns a View instance.\nkick.init = (component, el, data = {}) => {\n  if (el == null) { el = document.createElement('div'); }\n  component = kick.components[component];\n  let template = component.template.call(kick, el);\n  if (template instanceof HTMLElement) {\n    while (el.firstChild) {\n      el.removeChild(el.firstChild);\n    }\n    el.appendChild(template);\n  } else {\n    el.innerHTML = template;\n  }\n  const scope = component.initialize.call(kick, el, data);\n\n  let view = new View(el, scope)\n  view.bind()\n  return view\n}\n\n\nkick.formatters.negate = kick.formatters.not = (value) => {\n  return !value;\n};\n\nkick.formatters.call = (value, ...args) => {\n  if(!args.length) {return;}\n  let fn = args[0]\n  args = Array.prototype.slice.call(args, 1)\n  //value.call(...args)\n  return fn.call(value, ...args)\n  /* fix later if needs to be\n  return () => {\n      return fn.apply(null, value, ...args);\n  }\n  */\n}\n\nexport default kick\n"],"names":["OPTIONS","EXTENSIONS","QUOTED_STR","WHITESPACES","split","parseType","string","type","value","test","slice","undefined","isNaN","Number","parseTemplate","template","delimiters","tokens","length","index","lastIndex","open","close","indexOf","push","substring","lastToken","trim","parseFnExpr","expr","jsNested","statement","regex","RegExp","root","_","k","t","r","exec","results","chars","level","temp","match","temp2","parameters","forEach","char","s","e","node","p","wrappedNode","adapters","interfaces","rootInterface","kick","context","ev","binding","processedArgs","parseFormatterArguments","fnArgs","call","view","models","el","setAttribute","this","removeAttribute","options","keys","option","key","isObject","obj","Observer","keypath","callback","objectPath","parse","getRootObject","target","realize","set","updateOptions","Object","tokenize","chr","current","i","path","charAt","prototype","message","Error","substr","pop","prev","token","unreached","get","splice","sync","next","oldValue","newValue","Function","Array","setValue","active","action","unobserve","rootProp","$parent","FORMATTER_ARGS","FORMATTER_SPLIT","FN_CHECK","Binding","binder","arg","formatters","formatterObservers","model","locked","subscribers","observe","parseTarget","fnExpr","map","x","observer","args","formatterIndex","ai","_this","formattedValue","reduce","result","declaration","id","shift","formatter","_this2","read","eventHandler","fn","handler","function","routineFn","routine","callSubscribers","publish","reduceRight","_this3","getValue","bind","hasOwnProperty","preloadData","unbind","_this4","fi","update","checked","selected","subscribe","listener","item","fellow","bindings","find","_this5","textBinder","data","DECLARATION_SPLIT","binderPrefixes","parseNode","block","nodeType","templateDelimiters","text","document","createTextNode","parentNode","insertBefore","buildBinding","removeChild","traverse","childNodes","bindingComparator","a","b","aPriority","priority","trimStr","str","View","els","jquery","build","pipes","forExp","len","elements","sort","binderType","identifier","nodeName","attributes","bindInfos","varBinders","attribute","startWithBinder","name","binderMap","binders","fallbackBinder","attr","bindInfo","components","_bound","ComponentBinding","publishes","prefix","some","pre","ARRAY_METHODS","adapter","counter","defineProperty","weakmap","__rv","ref","callbacks","pointers","original","weakReference","response","apply","stubFunction","idx","cleanupWeakReference","desc","getOwnPropertyDescriptor","configurable","unobserveMutations","observeMutations","getString","toString","createView","anchorEl","cloneNode","marker","removeEventListener","addEventListener","iterated","createComment","collection","modelName","indexProp","getAttribute","matchIndex","nextView","nextIndex","previous","nextSibling","n","cb","propertyName","style","elClass","className","replace","textContent","innerHTML","display","disabled","self","isRadio","tagName","event","bound","nested","attached","elm","querySelector","viewOptions","extensionType","create","filter","init","component","createElement","HTMLElement","firstChild","appendChild","scope","initialize","negate","not"],"mappings":"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"}