{"version":3,"file":"kick.min.js","sources":["../src/constants.js","../src/parsers.js","../src/kick.js","../src/observer.js","../src/view.js","../src/binders.js","../src/bindings.js","../src/adapter.js","../src/component.js","../src/export.js","../src/formatters.js"],"sourcesContent":["export const OPTIONS = [\n  //'prefix',\n  'templateDelimiters',\n  'rootInterface',\n  'preloadData',\n  'handler'\n]\n\nexport const COMPS = 'components'\n\nexport const EXTENSIONS = [\n  'binders',\n  'formatters',\n  COMPS,\n  'adapters'\n]","const PRIMITIVE = 0;\nconst KEYPATH = 1;\nconst TEXT = 0;\nconst BINDING = 1;\n\nconst QUOTED_STR = /^'.*'$|^\".*\"$/;\nconst WHITESPACES = ' \\n\\r\\t'.split('');\n\n// Parser and tokenizer for getting the type and value from a string.\nexport function parseType(string) {\n  let type = PRIMITIVE;\n  let value = string;\n\n  if (QUOTED_STR.test(string)) {\n    value = string.slice(1, -1);\n  } else if (string === \"true\") {\n    value = true;\n  } else if (string === \"false\") {\n    value = false;\n  } else if (string === \"null\") {\n    value = null;\n  } else if (string === \"undefined\") {\n    value = undefined;\n  } else if (!isNaN(string)) {\n    value = Number(string);\n  } else {\n    type = KEYPATH;\n  }\n\n  return { type: type, value: value };\n}\n\n// Template parser and tokenizer for mustache-style text content bindings.\n// Parses the template and returns a set of tokens, separating static portions\n// of text from binding declarations.\nexport function parseTemplate(template, delimiters) {\n  var tokens;\n  let length = template.length;\n  let index = 0;\n  let lastIndex = 0;\n  let open = delimiters[0],\n    close = delimiters[1];\n\n  while (lastIndex < length) {\n    index = template.indexOf(open, lastIndex);\n\n    if (index < 0) {\n      if (tokens) {\n        tokens.push({\n          type: TEXT,\n          value: template.slice(lastIndex)\n        });\n      }\n\n      break;\n    } else {\n      tokens || (tokens = []);\n      if (index > 0 && lastIndex < index) {\n        tokens.push({\n          type: TEXT,\n          value: template.slice(lastIndex, index)\n        });\n      }\n\n      lastIndex = index + open.length;\n      index = template.indexOf(close, lastIndex);\n\n      if (index < 0) {\n        let substring = template.slice(lastIndex - close.length);\n        let lastToken = tokens[tokens.length - 1];\n\n        if (lastToken && lastToken.type === TEXT) {\n          lastToken.value += substring;\n        } else {\n          tokens.push({\n            type: TEXT,\n            value: substring\n          });\n        }\n\n        break;\n      }\n\n      let value = template.slice(lastIndex, index).trim();\n\n      tokens.push({\n        type: BINDING,\n        value: value\n      });\n\n      lastIndex = index + close.length;\n    }\n  }\n\n  return tokens;\n}\n\nexport function parseFnExpr(expr) {\n  function jsNested(statement) {\n    var regex = new RegExp(\"([a-zA-Z0-9_$]+)\\\\((.*)\\\\)\", \"g\");\n    var root = { _: [] };\n\n    if (QUOTED_STR.test(statement)) {\n      root._.push({ k: statement, t: \"l\" });\n      return root;\n    }\n\n    var r = regex.exec(statement);\n    if (!r || r.length < 3) {\n      return root;\n    }\n    var parameters = args(r[2]);\n    var node = { _: [] };\n    parameters.forEach(function(p) {\n      if (p.e) {\n        if (p.e.indexOf(\"(\") == -1) {\n          node._.push({ k: p.e, t: \"p\" });\n        } else {\n          var wrappedNode = jsNested(p.e),\n            k;\n          for (k in wrappedNode) {\n            node._.push(wrappedNode[k][0]);\n          }\n        }\n      } else {\n        //node[p.s] = p.s;\n      }\n    });\n\n    // Assign node to the node's identifier\n    root._.push({ k: r[1], t: 'f', _: node._ });\n    //root._.push(r[1]:node);\n    return root;\n  }\n\n  function args(statement) {\n    statement += \",\"; // so I don't have to handle the \"last, leftover parameter\"\n    var results = [];\n    var chars = statement.split(\"\");\n    var level = 0; // levels of parenthesis, used to track how deep I am in ().\n    var index = 0; // determines which parameter am I currently on.\n    var temp = \"\", match = '', temp2 = '';\n    chars.forEach(function(char) {\n      switch (true) {\n        case char === \"'\":\n        case char === '\"':\n          if (match.length && match === char) {\n            temp += match + temp2 + match;\n            results[index] = { s: temp2 };\n            match = temp2 = '';\n            //level--;\n            //temp = '';\n            index++;\n          } else {\n            match = char;\n            //level++;\n          }\n          //level++;\n          break;\n        case !match.length && WHITESPACES.indexOf(char) !== -1:\n          break;\n        case !match.length && char === '(':\n          temp += char;\n          level++;\n          break;\n        case !match.length && char === ')':\n          temp += char;\n          level--;\n          break;\n        case !match.length && char === ',':\n          // if the comma is between a set of parenthesis, ignore.\n          if (level !== 0) {\n            temp += char;\n          }\n          // if the comma is external, split the string.\n          else {\n            results[index] = { e: temp };\n            temp = '';\n            index++;\n          }\n          break;\n        default:\n          if (match.length) {\n            temp2 += char;\n          } else {\n            temp += char;\n          }\n          break;\n      }\n    });\n    return results;\n  } \n\n  //return if we were able to parse functions otherwise it will be null\n  return jsNested(expr)._[0] || null;\n}\n\n\n// Someone bored at http://jsfiddle.net/ryanwheale/e8aaa8ny/3/\nlet parseEngine = {\n  toSourceString: function(obj, recursion) {\n      let strout = \"\";\n      \n      recursion = recursion || 0;\n      for(let prop in obj) {\n          if (obj.hasOwnProperty(prop)) {\n              strout += recursion ? \"    \" + prop + \": \" : \"var \" + prop + \" = \";\n              switch (typeof obj[prop]) {\n                  case \"string\":\n                  case \"number\":\n                  case \"boolean\":\n                  case \"undefined\":\n                      strout += JSON.stringify(obj[prop]);\n                      break;\n                      \n                  case \"function\":\n                      // won't work in older browsers\n                      strout += obj[prop].toString();\n                      break;\n                      \n                  case \"object\":\n                      if (!obj[prop])\n                          strout += JSON.stringify(obj[prop]);\n                      else if (obj[prop] instanceof RegExp)\n                          strout += obj[prop].toString();\n                      else if (obj[prop] instanceof Date)\n                          strout += \"new Date(\" + JSON.stringify(obj[prop]) + \")\";\n                      else if (obj[prop] instanceof Array)\n                          strout += \"Array.prototype.slice.call({\\n \"\n                              + this.toSourceString(obj[prop], recursion + 1)\n                              + \"    length: \" + obj[prop].length\n                          + \"\\n })\";\n                      else\n                          strout += \"{\\n \"\n                              + this.toSourceString(obj[prop], recursion + 1).replace(/\\,\\s*$/, '')\n                          + \"\\n }\";\n                      break;\n              }\n              \n              strout += recursion ? \",\\n \" : \";\\n \";\n          }\n      }\n      return strout;\n  },\n  evaluate: function(strInput, obj) {\n      let str = this.toSourceString(obj);\n      console.log(str);\n      return (new Function(str + 'return ' + strInput))();\n  }\n};\n\n// Haven't tested yet just a fluke or placeholder\nexport function parseExpr(expr, ctx){\n  //console.log(engine.evaluate(strFn, context));\n  return parseEngine.evaluate(expr, ctx);\n}","import {EXTENSIONS} from './constants'\nimport {parseTemplate, parseType} from './parsers'\n\nconst kick = {\n  // Global binders.\n  binders: {},\n\n  // Global formatters.\n  formatters: {},\n\n  // Global components.\n  components: {},\n\n  // Global sightglass adapters.\n  adapters: {},\n\n  /*\n  // Default attribute prefix.\n  _prefix: 'rv',\n\n  _fullPrefix: 'rv-',\n\n  /* get prefix () {\n    return this._prefix\n  },\n\n  set prefix (value) {\n    this._prefix = value\n    this._fullPrefix = value + '-'\n  }, */\n\n  parseTemplate: parseTemplate,\n\n  parseType: parseType,\n\n  // Default template delimiters.\n  templateDelimiters: ['{{', '}}'],\n\n  // Binder shortcuts - extend it if you want to have your own\n  // else if(nodeName === '?') {nodeName = 'if';}\n\n  binderMap: {\n    '^': '^click',\n    '^^': '^dblclick',\n    '^_': '^contextmenu',\n    '^@': '^change',\n    '^+': '^focus',\n    '^-': '^blur',\n    '@': '@value',\n    '@x': '@checked',\n    '@-x': '@unchecked',\n    ':' : ':text',\n    '::' : ':html',\n    '$' : ':html',\n    '+': ':show',\n    '-': ':hide',\n    '~': ':disabled',\n    '~~': ':enabled',\n    '-~': ':enabled'\n    },\n    // was starBinder in rivetsjs, in kickjs *(star) is used for foreach binding so changing it to varBinder as an variable binder\n    varBinderMap: {\n      '.&': ':class-&',\n      '-.&': '-:class-&',\n      '..&': ':style-&',\n      '-..&': '-:style-&',\n      ':&': ':attr-&',\n      '-:&': '-:attr-&',\n    },\n  // Default sightglass root interface.\n  rootInterface: '.',\n\n  // Preload data by default.\n  preloadData: true,\n\n  // Default event handler.\n  handler: function(context, ev, binding) {\n    // changing the order of returns as well as passed arguments first then $event\n    // todo document this breakig change\n    const processedArgs = binding.parseFormatterArguments(binding.fnArgs, 0, ev, binding.view.models);\n    let fns = this.name.split(' ')\n    let fn = fns[fns.length - 1]\n    if(!fn || fn === ''){\n      //, binding.view.models, ev\n      this.call(context, ...[...processedArgs])\n    } else {\n      let ctx = binding.model\n      ctx[fn].call(ctx, ...[...processedArgs])\n    }\n  },\n\n  // Sets the attribute on the element. If no binder above is matched it will fall\n  // back to using this binder.\n  fallbackBinder: function(el, value) {\n    if (value != null) {\n      // is this a component?\n      let type = this.type;\n      let comp = customElements.get(el.localName)\n      if(type.substr(0,1) === ':'){ type = type.substr(1); }\n      if(comp && comp.properties && comp.properties[type] !== undefined){\n        let mapType = comp.properties[type]; \n        el[mapType] = value;\n      } else {\n        el.setAttribute(type, value)\n      }\n    } else {\n      el.removeAttribute(this.type)\n    }\n  },\n\n  // Merges an object literal into the corresponding global options.\n  configure: function(options) {\n    if (!options) {\n      return\n    }\n    Object.keys(options).forEach(option => {\n      let value = options[option]\n\n      if (EXTENSIONS.indexOf(option) > -1) {\n        Object.keys(value).forEach(key => {\n          this[option][key] = value[key]\n        })\n      } else {\n        this[option] = value\n      }\n    })\n  },\n\n  router:{}\n}\n\nexport default kick\n","\n// Check if a value is an object than can be observed.\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null\n}\n\n// Error thrower.\nfunction error(message) {\n  throw new Error('[Observer] ' + message)\n}\n\nvar adapters\nvar interfaces\nvar rootInterface\n\n// Constructs a new keypath observer and kicks things off.\nfunction Observer(obj, keypath, callback) {\n  this.keypath = keypath\n  this.callback = callback\n  this.objectPath = []\n  this.parse()\n  this.obj = this.getRootObject(obj)\n\n  if (isObject(this.target = this.realize())) {\n    this.set(true, this.key, this.target, this.callback)\n  }\n}\n\nObserver.updateOptions = function(options) {\n  adapters = options.adapters\n  interfaces = Object.keys(adapters)\n  rootInterface = options.rootInterface\n}\n\n// Tokenizes the provided keypath string into interface + path tokens for the\n// observer to work with.\nObserver.tokenize = function(keypath, root) {\n  var tokens = []\n  var current = {i: root, path: ''}\n  var index, chr\n\n  for (index = 0; index < keypath.length; index++) {\n    chr = keypath.charAt(index)\n\n    if (!!~interfaces.indexOf(chr)) {\n      tokens.push(current)\n      current = {i: chr, path: ''}\n    } else {\n      current.path += chr\n    }\n  }\n\n  tokens.push(current)\n  return tokens\n}\n\n// Parses the keypath using the interfaces defined on the view. Sets variables\n// for the tokenized keypath as well as the end key.\nObserver.prototype.parse = function() {\n  var path, root\n\n  if (!interfaces.length) {\n    error('Must define at least one adapter interface.')\n  }\n\n  if (!!~interfaces.indexOf(this.keypath[0])) {\n    root = this.keypath[0]\n    path = this.keypath.substr(1)\n  } else {\n    root = rootInterface\n    path = this.keypath\n  }\n\n  this.tokens = Observer.tokenize(path, root)\n  this.key = this.tokens.pop()\n}\n\n// Realizes the full keypath, attaching observers for every key and correcting\n// old observers to any changed objects in the keypath.\nObserver.prototype.realize = function() {\n  var current = this.obj\n  var unreached = -1\n  var prev\n  var token\n\n  for (let index = 0; index < this.tokens.length; index++) {\n    token = this.tokens[index]\n    if (isObject(current)) {\n      if (typeof this.objectPath[index] !== 'undefined') {\n        if (current !== (prev = this.objectPath[index])) {\n          this.set(false, token, prev, this)\n          this.set(true, token, current, this)\n          this.objectPath[index] = current\n        }\n      } else {\n        this.set(true, token, current, this)\n        this.objectPath[index] = current\n      }\n\n      current = this.get(token, current)\n    } else {\n      if (unreached === -1) {\n        unreached = index\n      }\n\n      if (prev = this.objectPath[index]) {\n        this.set(false, token, prev, this)\n      }\n    }\n  }\n\n  if (unreached !== -1) {\n    this.objectPath.splice(unreached)\n  }\n\n  return current\n}\n\n// Updates the keypath. This is called when any intermediary key is changed.\nObserver.prototype.sync = function() {\n  var next, oldValue, newValue\n\n  if ((next = this.realize()) !== this.target) {\n    if (isObject(this.target)) {\n      this.set(false, this.key, this.target, this.callback)\n    }\n\n    if (isObject(next)) {\n      this.set(true, this.key, next, this.callback)\n    }\n\n    oldValue = this.value()\n    this.target = next\n    newValue = this.value()\n    if (newValue !== oldValue || newValue instanceof Function) this.callback.sync()\n  } else if (next instanceof Array) {\n    this.callback.sync()\n  }\n}\n\n// Reads the current end value of the observed keypath. Returns undefined if\n// the full keypath is unreachable.\nObserver.prototype.value = function() {\n  if (isObject(this.target)) {\n    return this.get(this.key, this.target)\n  }\n}\n\n// Sets the current end value of the observed keypath. Calling setValue when\n// the full keypath is unreachable is a no-op.\nObserver.prototype.setValue = function(value) {\n  if (isObject(this.target)) {\n    adapters[this.key.i].set(this.target, this.key.path, value)\n  }\n}\n\n// Gets the provided key on an object.\nObserver.prototype.get = function(key, obj) {\n  return adapters[key.i].get(obj, key.path)\n}\n\n// Observes or unobserves a callback on the object using the provided key.\nObserver.prototype.set = function(active, key, obj, callback) {\n  var action = active ? 'observe' : 'unobserve'\n  adapters[key.i][action](obj, key.path, callback)\n}\n\n\n// Unobserves the entire keypath.\nObserver.prototype.unobserve = function() {\n  var obj\n  var token\n\n  for (let index = 0; index < this.tokens.length; index++) {\n    token = this.tokens[index]\n    if (obj = this.objectPath[index]) {\n      this.set(false, token, obj, this)\n    }\n  }\n\n  if (isObject(this.target)) {\n    this.set(false, this.key, this.target, this.callback)\n  }\n}\n// traverse the scope chain to find the scope which has the root property\n// if the property is not found in chain, returns the root scope\nObserver.prototype.getRootObject = function (obj) {\n  var rootProp, current;\n  if (!obj.$parent) {\n    return obj;\n  }\n\n  if (this.tokens.length) {\n    rootProp = this.tokens[0].path\n  } else {\n    rootProp = this.key.path\n  }\n\n  current = obj;\n  while (current.$parent && (current[rootProp] === undefined)) {\n    current = current.$parent\n  }\n\n  return current;\n}\n\nexport default Observer\n","import kick from './kick'\nimport {Binding} from './bindings'\nimport {parseTemplate} from './parsers'\n//import ComponentBinding from './components'\n\nconst textBinder = {\n  routine: (node, value) => {\n    node.data = (value != null) ? value : ''\n  }\n}\n\nconst DECLARATION_SPLIT = /((?:'[^']*')*(?:(?:[^\\|']*(?:'[^']*')+[^\\|']*)+|[^\\|]+))|^$/g\nconst ESCAPE_BINDER = /[.*+?^${}()|[\\]\\\\]/g\nconst ESCAPE_BINDER_WITH = '\\\\$&'\nconst binderPrefixes = '@:^.-+?!*#$~'.split('')\n\n\nconst parseNode = (view, node) => {\n  let block = false\n\n  if (node.nodeType === 3) {\n    let tokens = parseTemplate(node.data, kick.templateDelimiters)\n\n    if (tokens) {\n      for (let i = 0; i < tokens.length; i++) {\n        let token = tokens[i]\n        let text = document.createTextNode(token.value)\n        node.parentNode.insertBefore(text, node)\n\n        if (token.type === 1) {\n          view.buildBinding(text, null, token.value, textBinder, null)\n        }\n      }\n\n      node.parentNode.removeChild(node)\n    }\n    block = true\n  } else if (node.nodeType === 1) {\n    block = view.traverse(node)\n  }\n\n  if (!block) {\n    for (let i = 0; i < node.childNodes.length; i++) {\n      parseNode(view, node.childNodes[i]);\n    }\n  }\n}\n\nconst bindingComparator = (a, b) => {\n  let aPriority = a.binder ? (a.binder.priority || 0) : 0\n  let bPriority = b.binder ? (b.binder.priority || 0) : 0\n  return bPriority - aPriority\n}\n\nconst trimStr = (str) => {\n  return str.trim()\n}\n\n// A collection of bindings built from a set of parent nodes.\nexport default class View {\n  // The DOM elements and the model objects for binding are passed into the\n  // constructor along with any local options that should be used throughout the\n  // context of the view and it's bindings.\n  constructor(els, models, options) {\n    if (els.jquery || els instanceof Array) {\n      this.els = els\n    } else {\n      this.els = [els]\n    }\n\n    this.models = models\n    this.options = options\n\n    this.build()\n  }\n\n\n  buildBinding(node, type, declaration, binder, arg) {\n    let pipes = declaration.match(DECLARATION_SPLIT).map(trimStr)\n\n    let keypath = pipes.shift()\n\n    if(arg === '' && type === '*'){\n      // resolve for in expression, useful for case sensitive members e.g. myItem in items\n      const forRE = new RegExp(/^(.+)\\s+in\\s+(.[^|\\s]+)(.*)$/gm);\n      let forExp = forRE.exec(keypath);\n      // console.log(forExp)\n      if(forExp && forExp.length > 2){\n        arg = forExp[1] || arg\n        keypath = forExp[2] || keypath\n      }\n      // console.log(forExp[3].split('|'))\n    }\n\n    this.bindings.push(new Binding(this, node, type, keypath, binder, arg, pipes))\n  }\n\n  // Parses the DOM tree and builds `Binding` instances for every matched\n  // binding declaration.\n  build() {\n    this.bindings = []\n\n    let elements = this.els, i, len;\n    for (i = 0, len = elements.length; i < len; i++) {\n      parseNode(this, elements[i])\n    }\n\n    this.bindings.sort(bindingComparator)\n  }\n\n  traverse(node) {\n    // let bindingPrefix = kick._fullPrefix\n    let block = node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE'\n    let attributes = node.attributes\n    let bindInfos = []\n    let varBinders = this.options.varBinders\n    let mappedBinder\n    var binderType, binder, identifier, arg\n\n    for (let i = 0, len = attributes.length; i < len; i++) {\n      let attribute = attributes[i]\n      // if (attribute.name.indexOf(bindingPrefix) === 0) {\n      if (this.startWithBinder(attribute.name)) {\n          // binderType = attribute.name.slice(bindingPrefix.length);\n          mappedBinder = kick.binderMap[attribute.name];\n          binderType = mappedBinder || attribute.name;\n\n        // type = attribute.name.slice(bindingPrefix.length)\n        binder = this.options.binders[binderType]\n        arg = undefined\n\n        if (!binder) {\n          for (let k = 0; k < varBinders.length; k++) {\n            identifier = varBinders[k]\n            if (binderType.slice(0, identifier.length - 1) === identifier.slice(0, -1)) {\n              binder = this.options.binders[identifier]\n              arg = binderType.slice(identifier.length - 1)\n              break\n            }\n          }\n        }\n\n        if (!binder) {\n          binder = kick.fallbackBinder\n        }\n\n        if (binder.block) {\n          this.buildBinding(node, binderType, attribute.value, binder, arg)\n          node.removeAttribute(attribute.name)\n          return true;\n        }\n\n        bindInfos.push({attr: attribute, binder: binder, type: binderType, arg: arg})\n      }\n    }\n\n    for (let i = 0; i < bindInfos.length; i++) {\n      let bindInfo = bindInfos[i]\n      this.buildBinding(node, bindInfo.type, bindInfo.attr.value, bindInfo.binder, bindInfo.arg)\n      node.removeAttribute(bindInfo.attr.name)\n    }\n\n    if (kick.components[binderType] && !node._bound) {\n       this.bindings.push(new ComponentBinding(this, node, binderType));\n       block = true;\n    }\n\n    return block\n  }\n\n  // Binds all of the current bindings for this view.\n  bind() {\n    this.bindings.forEach(binding => {\n      binding.bind()\n    })\n  }\n\n  // Unbinds all of the current bindings for this view.\n  unbind() {\n    this.bindings.forEach(binding => {\n      binding.unbind()\n    })\n  }\n\n  // Syncs up the view with the model by running the routines on all bindings.\n  sync() {\n    this.bindings.forEach(binding => {\n      binding.sync()\n    })\n  }\n\n  // Publishes the input values from the view back to the model (reverse sync).\n  publish() {\n    this.bindings.forEach(binding => {\n      if (binding.binder && binding.binder.publishes) {\n        binding.publish()\n      }\n    })\n  }\n\n  // Updates the view's models along with any affected bindings.\n  update(models = {}) {\n    Object.keys(models).forEach(key => {\n      this.models[key] = models[key]\n    })\n\n    this.bindings.forEach(binding => {\n      if (binding.update) {\n        binding.update(models)\n      }\n    })\n  }\n\n  // move it to utils\n  startWithBinder(name) {\n    const prefix = name.substr(0, 1)\n    return binderPrefixes.some((pre) => pre === prefix)\n  }\n}\n","import View from './view'\nimport kick from './kick';\n\n// adding jQuery support to handle bootstrap and common vast plugin support\nconst has$ = (window.jQuery ? true : false)\nconst on = (el, arg, handler) => {has$ ? $(el).on(arg, handler) : el.addEventListener(arg, handler)}\nconst off = (el, arg, handler) => {has$ ? $(el).off(arg, handler) : el.removeEventListener(arg, handler)}\n\nconst getString = (value) => {\n  return value != null ? value.toString() : undefined\n}\n\nconst times = (n, cb) => {\n  for (let i = 0; i < n; i++) cb()\n}\n\nfunction createView(binding, data, anchorEl) {\n  let template = binding.el.cloneNode(true)\n  let view = new View(template, data, binding.view.options)\n  view.bind()\n  binding.marker.parentNode.insertBefore(template, anchorEl)\n  return view\n}\n\nconst binders = {\n  // Binds an event handler on the element.\n  '^&': {\n    function: true,\n    priority: 1000,\n\n    unbind: function(el) {\n      if (this.handler) {\n        off(el, this.arg, this.handler)\n      }\n    },\n\n    routine: function(el, value) {\n      if (this.handler) {\n        off(el, this.arg, this.handler)\n      }\n\n      this.handler = this.eventHandler(value)\n      on(el, this.arg, this.handler)\n    }\n  },\n\n  // for $item Appends bound instances of the element in place for item in the array.\n  '*&': {\n    block: true,\n\n    priority: 4000,\n\n    bind: function(el) {\n      if (!this.marker) {\n        this.marker = document.createComment(` kick: ${this.type} `)\n        this.iterated = []\n\n        el.parentNode.insertBefore(this.marker, el)\n        el.parentNode.removeChild(el)\n      } else {\n        this.iterated.forEach(view => {\n          view.bind()\n        })\n      }\n    },\n\n    unbind: function(el) {\n      if (this.iterated) {\n        this.iterated.forEach(view => {\n          view.unbind()\n        })\n      }\n    },\n\n    routine: function(el, collection) {\n      let modelName = this.arg || '$item'\n      collection = collection || []\n      let indexProp = el.getAttribute('#index') || el.getAttribute('index-property') || '$index'\n\n      collection.forEach((model, index) => {\n        let data = {$parent: this.view.models}\n        data[indexProp] = index\n        data[modelName] = model\n        let view = this.iterated[index]\n\n        if (!view) {\n\n          let previous = this.marker\n\n          if (this.iterated.length) {\n            previous = this.iterated[this.iterated.length - 1].els[0]\n          }\n\n          view = createView(this, data, previous.nextSibling)\n          this.iterated.push(view)\n        } else {\n          if (view.models[modelName] !== model) {\n            // search for a view that matches the model\n            let matchIndex, nextView\n            for (let nextIndex = index + 1; nextIndex < this.iterated.length; nextIndex++) {\n              nextView = this.iterated[nextIndex]\n              if (nextView.models[modelName] === model) {\n                matchIndex = nextIndex\n                break\n              }\n            }\n            if (matchIndex !== undefined) {\n              // model is in other position\n              // todo: consider avoiding the splice here by setting a flag\n              // profile performance before implementing such change\n              this.iterated.splice(matchIndex, 1)\n              this.marker.parentNode.insertBefore(nextView.els[0], view.els[0])\n              nextView.models[indexProp] = index\n            } else {\n              //new model\n              nextView = createView(this, data, view.els[0])\n            }\n            this.iterated.splice(index, 0, nextView)\n          } else {\n            view.models[indexProp] = index\n          }\n        }\n      })\n\n      if (this.iterated.length > collection.length) {\n        times(this.iterated.length - collection.length, () => {\n          let view = this.iterated.pop()\n          view.unbind()\n          this.marker.parentNode.removeChild(view.els[0])\n        })\n      }\n\n      if (el.nodeName === 'OPTION') {\n        this.view.bindings.forEach(binding => {\n          if (binding.el === this.marker.parentNode && binding.type === 'value') {\n            binding.sync()\n          }\n        })\n      }\n    },\n\n    update: function(models) {\n      let data = {}\n\n      //todo: add test and fix if necessary\n      Object.keys(models).forEach(key => {\n        if (key !== this.arg) {\n          data[key] = models[key]\n        }\n      })\n\n      this.iterated.forEach(view => {\n        view.update(data)\n      })\n    }\n  },\n\n  // Order of ..& should be before .& otherwise match will trigger shorter length first\n  // removes the style from the element when there is value\n  '-..&': function(el, value) {\n    const propertyName = this.arg;\n    if (value) {\n      el.style[propertyName] = '';\n    } else {\n      // do nothing\n      //el.style[propertyName] = value;\n    }\n  },\n\n  // Order of ..& should be before .& otherwise match will trigger shorter length first\n  // Adds or removes the style from the element when there is value\n  '..&': function(el, value) {\n    const propertyName = this.arg;\n    if (value) {\n      el.style[propertyName] = value;\n    } else {\n      el.style[propertyName] = '';\n    }\n  },\n\n  // Adds or removes the class from the element when value is false or true.\n  '-.&': function(el, value) {\n    let elClass = ` ${el.className} `\n\n    if (value === (elClass.indexOf(` ${this.arg} `) > -1)) {\n      if (value) {\n        el.className = elClass.replace(` ${this.arg} `, ' ').trim()\n      } else {\n        el.className = `${el.className} ${this.arg}`\n      }\n    }\n  },\n\n  // Adds or removes the class from the element when value is true or false.\n  '.&': function(el, value) {\n    let elClass = ` ${el.className} `\n\n    if (!value === (elClass.indexOf(` ${this.arg} `) > -1)) {\n      if (value) {\n        el.className = `${el.className} ${this.arg}`\n      } else {\n        el.className = elClass.replace(` ${this.arg} `, ' ').trim()\n      }\n    }\n  },\n\n  // Sets the element's text value.\n  ':text': (el, value) => {\n    el.textContent = value != null ? value : ''\n  },\n\n  // Sets the element's HTML content.\n  ':html': (el, value) => {\n    el.innerHTML = value != null ? value : ''\n  },\n  \n  // Shows the element when value is true.\n  ':show': (el, value) => {\n    el.style.display = value ? '' : 'none'\n  },\n\n  // Hides the element when value is true (negated version of `show` binder).\n  ':hide': (el, value) => {\n    el.style.display = value ? 'none' : ''\n  },\n\n  // Enables the element when value is true.\n  ':enabled': (el, value) => {\n    el.disabled = !value\n  },\n\n  // Disables the element when value is true (negated version of `enabled` binder).\n  ':disabled': (el, value) => {\n    el.disabled = !!value\n  },\n\n  // Checks a checkbox or radio input when the value is true. Also sets the model\n  // property when the input is checked or unchecked (two-way binder).\n  // also \"@x\"\n  '@checked': {\n    publishes: true,\n    priority: 2000,\n\n    bind: function(el) {\n      var self = this;\n      if (!this.callback) {\n        this.callback = function () {\n          self.publish();\n        }\n      }\n      el.addEventListener('change', this.callback)\n    },\n\n    unbind: function(el) {\n      el.removeEventListener('change', this.callback)\n    },\n\n    routine: function(el, value) {\n      if (el.type === 'radio') {\n        el.checked = getString(el.value) === getString(value)\n      } else {\n        el.checked = !!value\n      }\n    }\n  },\n  // Unchecks a checkbox or radio input when the value is true. Also sets the model\n  // property when the input is checked or unchecked (two-way binder).\n  // also \"@-x\"\n  '@unchecked': {\n    publishes: true,\n    priority: 2000,\n\n    bind: function(el) {\n      var self = this;\n      if (!this.callback) {\n        this.callback = function () {\n          self.publish();\n        }\n      }\n      el.addEventListener('change', this.callback)\n    },\n\n    unbind: function(el) {\n      el.removeEventListener('change', this.callback)\n    },\n\n    routine: function(el, value) {\n      if (el.type === 'radio') {\n        el.checked = !(getString(el.value) === getString(value))\n      } else {\n        el.checked = !(!!value)\n      }\n    }\n  },\n\n  // Sets the element's value. Also sets the model property when the input changes\n  // (two-way binder).\n  '@value': {\n    publishes: true,\n    priority: 3000,\n\n    bind: function(el) {\n      this.isRadio = el.tagName === 'INPUT' && el.type === 'radio';\n      if (!this.isRadio) {\n        this.event = el.getAttribute('event-name') || (el.tagName === 'SELECT' ? 'change' : 'input')\n\n        var self = this;\n        if (!this.callback) {\n          this.callback = function () {\n            self.publish();\n          }\n        }\n\n        el.addEventListener(this.event, this.callback)\n      }\n    },\n\n    unbind: function(el) {\n      if (!this.isRadio) {\n        el.removeEventListener(this.event, this.callback)\n      }\n    },\n\n    routine: function(el, value) {\n      if (this.isRadio) {\n        el.setAttribute('value', value)\n      } else {\n        if (el.type === 'select-multiple') {\n          if (value instanceof Array) {\n            for (let i = 0; i < el.length; i++) {\n              let option = el[i];\n              option.selected = value.indexOf(option.value) > -1\n            }\n          }\n        } else if (getString(value) !== getString(el.value)) {\n          el.value = value != null ? value : ''\n        }\n      }\n    }\n  },\n\n  // Inserts and binds the element and it's child nodes into the DOM when true.\n  '?': {\n    block: true,\n    priority: 4000,\n\n    bind: function(el) {\n      if (!this.marker) {\n        this.marker = document.createComment(' kick: ' + this.type + ' ' + this.keypath + ' ');\n        this.attached = false\n\n        el.parentNode.insertBefore(this.marker, el)\n        el.parentNode.removeChild(el)\n      } else if (this.bound === false && this.nested) {\n        this.nested.bind()\n      }\n      this.bound = true\n    },\n\n    unbind: function() {\n      if (this.nested) {\n        this.nested.unbind()\n        this.bound = false\n      }\n    },\n\n    routine: function(el, value) {\n      if (!!value !== this.attached) {\n        if (value) {\n\n          if (!this.nested) {\n            this.nested = new View(el, this.view.models, this.view.options)\n            this.nested.bind()\n          }\n\n          this.marker.parentNode.insertBefore(el, this.marker.nextSibling)\n          this.attached = true\n        } else {\n          el.parentNode.removeChild(el)\n          this.attached = false\n        }\n      }\n    },\n\n    update: function(models) {\n      if (this.nested) {\n        this.nested.update(models)\n      }\n    }\n  },\n\n  // Inserts and binds the element and it's child nodes into the DOM when false.\n  '-?': {\n    block: true,\n    priority: 4001,\n\n    bind: function(el) {\n      if (!this.marker) {\n        this.marker = document.createComment(' kick: ' + this.type + ' ' + this.keypath + ' ');\n        this.attached = false\n\n        el.parentNode.insertBefore(this.marker, el)\n        el.parentNode.removeChild(el)\n      } else if (this.bound === false && this.nested) {\n        this.nested.bind()\n      }\n      this.bound = true\n    },\n\n    unbind: function() {\n      if (this.nested) {\n        this.nested.unbind()\n        this.bound = false\n      }\n    },\n\n    routine: function(el, value) {\n      if (!!value === this.attached) {\n        if (!value) {\n\n          if (!this.nested) {\n            this.nested = new View(el, this.view.models, this.view.options)\n            this.nested.bind()\n          }\n\n          this.marker.parentNode.insertBefore(el, this.marker.nextSibling)\n          this.attached = true\n        } else {\n          el.parentNode.removeChild(el)\n          this.attached = false\n        }\n      }\n    },\n\n    update: function(models) {\n      if (this.nested) {\n        this.nested.update(models)\n      }\n    }\n  },\n\n\n  ':&': function(el, value) {\n    if (value != null) {\n      el.setAttribute(this.arg, value)\n    } else {\n      el.removeAttribute(this.arg)\n    }\n  },\n  '-:&': function(el, value) {\n    if (value != null) {\n      el.removeAttribute(this.arg)\n    } else {\n      // take no action and keep the attribute if it is there\n      // el.setAttribute(this.arg, value)\n    }\n  }  \n}\n\nexport default binders\n","import { parseType, parseFnExpr } from \"./parsers\";\nimport Observer from \"./observer\";\nimport kick from './kick';\n\nfunction getInputValue(el) {\n  let results = [];\n  if (el.type === \"checkbox\") {\n    return el.checked;\n  } else if (el.type === \"select-multiple\") {\n    el.options.forEach(option => {\n      if (option.selected) {\n        results.push(option.value);\n      }\n    });\n\n    return results;\n  } else {\n    return el.value;\n  }\n}\n\nconst FORMATTER_ARGS = /[^\\s']+|'([^']|'[^\\s])*'|\"([^\"]|\"[^\\s])*\"/g;\nconst FORMATTER_SPLIT = /\\s+/;\nconst FN_CHECK = /\\(.*\\)/;\n\n// A single binding between a model attribute and a DOM element.\nexport class Binding {\n  // All information about the binding is passed into the constructor; the\n  // containing view, the DOM node, the type of binding, the model object and the\n  // keypath at which to listen for changes.\n  constructor(view, el, type, keypath, binder, arg, formatters) {\n    this.view = view;\n    this.el = el;\n    this.type = type;\n    this.keypath = keypath;\n    this.binder = binder;\n    this.arg = arg;\n    this.formatters = formatters;\n    this.formatterObservers = {};\n    this.model = undefined;\n\n    //new property in kick for fn args but not sure if this is the right way\n    this.fnArgs = [];\n    //new property in kick for subscribers to get notified if value is changing specifically for jquery plugins\n    this.subscribers = [];\n    //new property in kick for locking to avoid loops of updates, specifically for jquery plugins\n    this.locked = false;\n    // add object to hold listners so that they can be unbinded later\n    this.listeners = {};\n  }\n\n  // Observes the object keypath\n  observe(obj, keypath) {\n    return new Observer(obj, keypath, this);\n  }\n\n  parseTarget() {\n    if (this.keypath) {\n      let token = parseType(this.keypath);\n\n      if (token.type === 0) {\n        this.value = token.value;\n      } else {\n        if (FN_CHECK.test(this.keypath)) {\n          let fnExpr = parseFnExpr(this.keypath);\n          if (fnExpr) {\n            this.keypath = fnExpr.k;\n            this.fnArgs = fnExpr._.map(x => x.k);\n            //let fnArgs = fnExpr._.map(x => x.k)\n            //this.fnArgs = this.parseFormatterArguments(fnArgs, 0)\n          }\n        }\n        this.observer = this.observe(this.view.models, this.keypath);\n        this.model = this.observer.target;\n      }\n    } else {\n      this.value = undefined;\n    }\n  }\n\n  parseFormatterArguments(args, formatterIndex, ev, vm) {\n    return args.map(parseType).map(({ type, value }, ai) => {\n      if (type === 0) {\n        return value;\n      } else if (value === '$ev') { //return event here\n          return ev;\n      } else if (value === '$vm') { //return model here\n          return vm;\n      } else if (value === '$el') { //return element here\n          return this.el;\n      } else {\n        if (!this.formatterObservers[formatterIndex]) {\n          this.formatterObservers[formatterIndex] = {};\n        }\n\n        let observer = this.formatterObservers[formatterIndex][ai];\n\n        if (!observer) {\n          observer = this.observe(this.view.models, value);\n          this.formatterObservers[formatterIndex][ai] = observer;\n        }\n\n        return observer.value();\n      }\n    });\n  }\n\n  // Applies all the current formatters to the supplied value and returns the\n  // formatted value.\n  formattedValue(value) {\n    return this.formatters.reduce((result, declaration, index) => {\n      let args = declaration.match(FORMATTER_ARGS);\n      let id = args.shift();\n      let formatter = this.view.options.formatters[id];\n\n      const processedArgs = this.parseFormatterArguments(args, index, null, this.view.models);\n\n      if (formatter && formatter.read instanceof Function) {\n        result = formatter.read(result, ...processedArgs);\n      } else if (formatter instanceof Function) {\n        result = formatter(result, ...processedArgs);\n      }\n      return result;\n    }, value);\n  }\n\n  // Returns an event handler for the binding around the supplied function.\n  eventHandler(fn) {\n    let binding = this;    \n    let handler = binding.view.options.handler;\n    let lfn = fn;\n\n    let type = this.type;\n    let el = this.el; \n    if(type.substr(0,1) === '^'){ type = type.substr(1); }\n    if(el.constructor && el.constructor.properties && el.constructor.properties[type] !== undefined){\n      let mapType = el.constructor.properties[type]; \n      el[mapType] = lfn;\n    } else {      \n      return function(ev) {\n        lfn && handler.call(lfn, this, ev, binding);\n      };\n    }\n  }\n\n  // Sets the value for the binding. This Basically just runs the binding routine\n  // with the supplied value formatted.\n  set(value) {\n    if (value instanceof Function && !this.binder.function) {\n      //todo update docs, probably a breaking change\n      const processedArgs = this.parseFormatterArguments(this.fnArgs, 0, null, this.view.models);\n      value = this.formattedValue(\n        value.call(this.model, ...[...processedArgs])\n      );\n      //value = this.formattedValue(value.call(this.model))\n    } else {\n      value = this.formattedValue(value);\n    }\n\n    let routineFn = this.binder.routine || this.binder;\n\n    if (routineFn instanceof Function) {\n      routineFn.call(this, this.el, value);\n      this.callSubscribers(value);\n    }\n  }\n\n  // Syncs up the view binding with the model.\n  sync() {\n    if (this.observer) {\n      this.model = this.observer.target;\n      this.set(this.observer.value());\n    } else {\n      this.set(this.value);\n    }\n  }\n\n  // Publishes the value currently set on the input element back to the model.\n  publish() {\n    if (this.observer) {\n      var value = this.formatters.reduceRight((result, declaration, index) => {\n        const args = declaration.split(FORMATTER_SPLIT);\n        const id = args.shift();\n        const formatter = this.view.options.formatters[id];\n        const processedArgs = this.parseFormatterArguments(args, index, null, this.view.models);\n\n        if (formatter && formatter.publish) {\n          result = formatter.publish(result, ...processedArgs);\n        }\n        return result;\n      }, this.getValue(this.el));\n\n      this.observer.setValue(value);\n    }\n  }\n\n  // Subscribes to the model for changes at the specified keypath. Bi-directional\n  // routines will also listen for changes on the element to propagate them back\n  // to the model.\n  bind() {\n    this.parseTarget();\n\n    if (this.binder.hasOwnProperty(\"bind\")) {\n      this.binder.bind.call(this, this.el);\n    }\n\n    if (this.view.options.preloadData) {\n      this.sync();\n    }\n  }\n\n  // Unsubscribes from the model and the element.\n  unbind() {\n    if (this.binder.unbind) {\n      this.binder.unbind.call(this, this.el);\n    }\n\n    if (this.observer) {\n      this.observer.unobserve();\n    }\n\n    Object.keys(this.formatterObservers).forEach(fi => {\n      let args = this.formatterObservers[fi];\n\n      Object.keys(args).forEach(ai => {\n        args[ai].unobserve();\n      });\n    });\n\n    this.formatterObservers = {};\n  }\n\n  // Updates the binding's model from what is currently set on the view. Unbinds\n  // the old model first and then re-binds with the new model.\n  update(models = {}) {\n    if (this.observer) {\n      this.model = this.observer.target;\n    }\n\n    if (this.binder.update) {\n      this.binder.update.call(this, models);\n    }\n  }\n\n  // Returns elements value\n  getValue(el) {\n    if (this.binder && this.binder.getValue) {\n      return this.binder.getValue.call(this, el);\n    } else {\n      return getInputValue(el);\n    }\n  }\n\n  // Subscribe to the value changes\n  subscribe(listener) {\n    var index = this.subscribers.push(listener) -1;\n\n    // Provide handle back for removal of listener\n    return {\n      remove: function() {\n        delete this.subscribers[index];\n      }\n    };\n  }\n\n  // Call the subscribers\n  callSubscribers(value){\n      // Cycle through subscribers queue, fire!\n      this.subscribers.forEach(function(item) {\n        item(value);\n    });      \n  }\n\n  // lock if not locked and returns false if already locked\n  lock(locking){\n    // return locked state if none provided\n    if(locking === undefined) {\n      return this.locked;\n    }  else if(this.locked === true && locking === true) {\n      // already locked asking again for same lock state\n      return false;\n    }\n\n    return this.locked = locking;\n  }\n\n  // Returns the next of kin bindings on the same element\n  kins(){\n    return this.view.bindings.filter((x)=> {return x.el === this.el});\n  }\n  // Returns the binding of a given type on the same element\n  kin(type){\n    let mappedType = kick.binderMap[type] || type;\n\n    return this.kins().find((x)=> {return x.type === mappedType;});\n  }\n}\n","// The default `.` adapter that comes with kick.js. Allows subscribing to\n// properties on plain objects, implemented in ES5 natives using\n// `Object.defineProperty`.\n\nconst ARRAY_METHODS = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'sort',\n  'reverse',\n  'splice'\n]\n\nconst adapter = {\n  counter: 0,\n  weakmap: {},\n\n  weakReference: function(obj) {\n    if (!obj.hasOwnProperty('__rv')) {\n      let id = this.counter++\n\n      Object.defineProperty(obj, '__rv', {\n        value: id\n      })\n    }\n\n    if (!this.weakmap[obj.__rv]) {\n      this.weakmap[obj.__rv] = {\n        callbacks: {}\n      }\n    }\n\n    return this.weakmap[obj.__rv]\n  },\n\n  cleanupWeakReference: function(ref, id) {\n    if (!Object.keys(ref.callbacks).length) {\n      if (!(ref.pointers && Object.keys(ref.pointers).length)) {\n        delete this.weakmap[id]\n      }\n    }\n  },\n\n  stubFunction: function(obj, fn) {\n    let original = obj[fn]\n    let map = this.weakReference(obj)\n    let weakmap = this.weakmap\n\n    obj[fn] = (...args) => {\n      let response = original.apply(obj, args)\n\n      Object.keys(map.pointers).forEach(r => {\n        let k = map.pointers[r]\n\n        if (weakmap[r]) {\n          if (weakmap[r].callbacks[k] instanceof Array) {\n            weakmap[r].callbacks[k].forEach(callback => {\n              callback.sync()\n            })\n          }\n        }\n      })\n\n      return response\n    }\n  },\n\n  observeMutations: function(obj, ref, keypath) {\n    if (obj instanceof Array) {\n      let map = this.weakReference(obj)\n\n      if (!map.pointers) {\n        map.pointers = {}\n\n        ARRAY_METHODS.forEach(fn => {\n          this.stubFunction(obj, fn)\n        })\n      }\n\n      if (!map.pointers[ref]) {\n        map.pointers[ref] = []\n      }\n\n      if (map.pointers[ref].indexOf(keypath) === -1) {\n        map.pointers[ref].push(keypath)\n      }\n    }\n  },\n\n  unobserveMutations: function(obj, ref, keypath) {\n    if ((obj instanceof Array) && (obj.__rv != null)) {\n      let map = this.weakmap[obj.__rv]\n\n      if (map) {\n        let pointers = map.pointers[ref]\n\n        if (pointers) {\n          let idx = pointers.indexOf(keypath)\n\n          if (idx > -1) {\n            pointers.splice(idx, 1)\n          }\n\n          if (!pointers.length) {\n            delete map.pointers[ref]\n          }\n\n          this.cleanupWeakReference(map, obj.__rv)\n        }\n      }\n    }\n  },\n\n  observe: function(obj, keypath, callback) {\n    var value;\n    let callbacks = this.weakReference(obj).callbacks\n\n    if (!callbacks[keypath]) {\n      callbacks[keypath] = []\n      let desc = Object.getOwnPropertyDescriptor(obj, keypath)\n\n      if (!desc || !(desc.get || desc.set || !desc.configurable)) {\n        value = obj[keypath]\n\n        Object.defineProperty(obj, keypath, {\n          enumerable: true,\n\n          get: () => {\n            return value\n          },\n\n          set: newValue => {\n            if (newValue !== value) {\n              this.unobserveMutations(value, obj.__rv, keypath)\n              value = newValue\n              let map = this.weakmap[obj.__rv]\n\n              if (map) {\n                let callbacks = map.callbacks[keypath]\n\n                if (callbacks) {\n                  callbacks.forEach(cb => {\n                      cb.sync()\n                  })\n                }\n\n                this.observeMutations(newValue, obj.__rv, keypath)\n              }\n            }\n          }\n        })\n      }\n    }\n\n    if (callbacks[keypath].indexOf(callback) === -1) {\n      callbacks[keypath].push(callback)\n    }\n\n    this.observeMutations(obj[keypath], obj.__rv, keypath)\n  },\n\n  unobserve: function(obj, keypath, callback) {\n    let map = this.weakmap[obj.__rv]\n\n    if (map) {\n      let callbacks = map.callbacks[keypath]\n\n      if (callbacks) {\n        let idx = callbacks.indexOf(callback)\n\n        if (idx > -1) {\n          callbacks.splice(idx, 1)\n\n          if (!callbacks.length) {\n            delete map.callbacks[keypath]\n            this.unobserveMutations(obj[keypath], obj.__rv, keypath)\n          }\n        }\n\n        this.cleanupWeakReference(map, obj.__rv)\n      }\n    }\n  },\n\n  get: function(obj, keypath) {\n    return obj[keypath]\n  },\n\n  set: (obj, keypath, value) => {\n    obj[keypath] = value\n  }\n}\n\nexport default adapter\n","import kick from './kick'\r\n\r\nclass Component extends HTMLElement {\r\n  static setObservedAttributes(_comp) {\r\n    const template = _comp.template\r\n    const tag = _comp.tag\r\n    if (!template || !tag) {\r\n      throw new Error(`No template or tag declared for ${this.name}`)\r\n    }\r\n    \r\n    _comp.__templateEl = document.createElement('template')\r\n    _comp.__templateEl.innerHTML = template\r\n    \r\n    const propAttributeMap = _comp.__propAttributeMap = {}\r\n    const attributes = []\r\n    const properties = _comp.properties\r\n    \r\n    if (properties) {\r\n      Object.keys(properties).forEach(propName => {\r\n        const propConfig = properties[propName]\r\n        const attrName = typeof propConfig === 'string' ? propConfig : propName\r\n        propAttributeMap[attrName] = propName        \r\n        attributes.push(attrName)\r\n        \r\n        // this.vm[propName] = propConfig\r\n      })\r\n    }    \r\n    return attributes\r\n  }\r\n  static get observedAttributes() {\r\n    return this.setObservedAttributes(this)\r\n  }\r\n\r\n\r\n  connectedCallback() {        \r\n    const nodes = this.constructor.__templateEl.content.cloneNode(true)\r\n    this.__kickView = kick.bind(nodes, this)\r\n    while (this.firstChild) {\r\n      this.removeChild(this.firstChild);\r\n    }\r\n    this.__kickView.sync()\r\n    this.appendChild(nodes)\r\n    this.__kickView.sync()\r\n    this.afterInit()\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    this.beforeExit()\r\n    this.__kickView.unbind()    \r\n  }\r\n\r\n  attributeChangedCallback(name, old, value) {\r\n    if (old !== value) {      \r\n      const propName = this.constructor.__propAttributeMap[name]\r\n      this[propName] = value\r\n    }\r\n  }\r\n  constructor(...args){\r\n    const self = super(...args)\r\n    // !this.properties && this.setObservedAttributes(this)\r\n    // this.__templateEl = document.createElement('template')\r\n    // this.__templateEl.innerHTML = this.template\r\n\r\n    //let templateContent = template.content\r\n\r\n\r\n    this.onInit()\r\n    return self\r\n  }\r\n  onInit(){}\r\n  afterInit(){}\r\n  beforeExit(){}\r\n  \r\n}\r\n\r\nexport default Component","import kick from './kick'\nimport View from './view'\nimport {OPTIONS, EXTENSIONS, COMPS} from './constants'\nimport binders from './binders'\nimport formatters from './formatters'\nimport adapter from './adapter'\nimport Observer from './observer'\n//import router from './router'\nimport Component from './component'\n\n// Returns the public interface.\nkick.binders = binders\nkick.formatters = formatters\nkick.adapters['.'] = adapter\nkick.Component = Component\n//kick.router = router\n\n// Binds some data to a template / element. Returns a kick.View instance.\nkick.bind = (elm, models, options, ) => {\n  // if element then return itself\n  elm = elm || '[kick-app]';\n  let el = (elm.nodeType && elm.nodeType > 0) ? elm : document.querySelector(elm);\n  kick.includeFile(el);\n\n  // refresh the el again after loading files\n  el = (elm.nodeType && elm.nodeType > 0) ? elm : document.querySelector(elm);\n\n  \n  let viewOptions = {}\n  models = models || {}\n  options = options || {}\n\n  EXTENSIONS.forEach(extensionType => {\n    viewOptions[extensionType] = Object.create(null)\n\n    if (options[extensionType]) {\n      Object.keys(options[extensionType]).forEach(key => {\n        viewOptions[extensionType][key] = options[extensionType][key]\n      })\n    }\n\n    Object.keys(kick[extensionType]).forEach(key => {\n      if (!viewOptions[extensionType][key]) {\n        viewOptions[extensionType][key] = kick[extensionType][key]\n      }\n    })\n  })\n\n  if(viewOptions[COMPS]){\n    Object.keys(viewOptions[COMPS]).forEach(key => {\n      let comp = viewOptions[COMPS][key]\n      //kick.components[comp.tag] = comp;\n      if(comp.tag && !customElements.get(comp.tag)){\n        customElements.define(comp.tag, comp)\n      }\n    })\n  }\n\n  OPTIONS.forEach(option => {\n    let value = options[option]\n    viewOptions[option] = value != null ? value : kick[option]\n  })\n\n  viewOptions.varBinders = Object.keys(viewOptions.binders).filter(function (key) {\n    return key.indexOf('&') > 0\n  })\n\n  Observer.updateOptions(viewOptions)\n\n  let view = new View(el, models, viewOptions)\n  view.bind()\n  return view\n}\n\n// Initializes a new instance of a component on the specified element and\n// returns a View instance.\nkick.init = (component, el, data = {}) => {\n  if (el == null) { el = document.createElement('div'); }\n  component = kick.components[component];\n  let template = component.template.call(kick, el);\n  if (template instanceof HTMLElement) {\n    while (el.firstChild) {\n      el.removeChild(el.firstChild);\n    }\n    el.appendChild(template);\n  } else {\n    el.innerHTML = template;\n  }\n  const scope = component.initialize.call(kick, el, data);\n\n  let view = new View(el, scope)\n  view.bind()\n  return view\n}\n\n\nkick.formatters.negate = kick.formatters.not = (value) => {\n  return !value;\n};\n\nkick.formatters.call = (value, ...args) => {\n  if(!args.length) {return;}\n  let fn = args[0]\n  args = Array.prototype.slice.call(args, 1)\n  //value.call(...args)\n  return fn.call(value, ...args)\n  /* fix later if needs to be\n  return () => {\n      return fn.apply(null, value, ...args);\n  }\n  */\n}\n\nkick.loadFile = (el, file) => {\n  /* Make an HTTP request using the attribute value as the file name: */\n  try {\n    let xhttp = new XMLHttpRequest();\n    xhttp.onreadystatechange = function() {\n      if (this.readyState == 4) {\n        if (this.status == 200) {\n          /* Remove the attribute, and call this function once more: */\n          if(el.tagName === 'KICKER'){\n            // replace el with new html\n            el.outerHTML = this.responseText;\n            // not sure about the below yet \n            // kick.includeFile(el.parent);\n          } else {\n            el.removeAttribute(\":file\");\n            el.innerHTML = this.responseText;\n            kick.includeFile(el);\n          }\n        }\n        else if (this.status == 404) {el.innerHTML = '<!-- ' + this.responseURL + ' not found. -->';}\n        else {el.innerHTML = '<!-- ' + this.responseText + ' -->';}\n      }\n    } \n    xhttp.open(\"GET\", file, false);\n    xhttp.send();\n  } catch (e) {\n    el.innerHTML = '<!-- Unable to connect to server -->';\n  }\n}\n\n// Sets the element's HTML content from file.\nkick.includeFile = (el) => {\n  let z, i, elmnt, file;\n  if(!el.getElementsByTagName){\n    if(el.children.length){\n      z = el.children;\n    } else {\n      return;\n    }\n  } else{\n    /* Loop through a collection of all HTML elements: */\n    z =  el.getElementsByTagName(\"*\");\n  } \n\n  for (i = 0; i < z.length; i++) {\n    elmnt = z[i];\n    /*search for elements with a certain atrribute:*/\n    file = elmnt.getAttribute(\":file\");\n    if (file) {\n      kick.loadFile(elmnt, file);\n    }\n  }\n}\n\nexport default kick\n","const formatters = {\r\n    watch: function(value) {\r\n      return value;\r\n    },\r\n  \r\n    not: function(value) {\r\n      return !value;\r\n    },\r\n  \r\n    negate: function(value) {\r\n      return !value;\r\n    }\r\n  }\r\n  \r\nexport default formatters"],"names":["OPTIONS","COMPS","EXTENSIONS","QUOTED_STR","WHITESPACES","split","parseType","string","type","value","test","slice","undefined","isNaN","Number","parseTemplate","template","delimiters","tokens","length","index","lastIndex","open","close","indexOf","push","substring","lastToken","trim","parseFnExpr","expr","jsNested","statement","regex","RegExp","root","_","k","t","r","exec","results","chars","level","temp","match","temp2","parameters","forEach","char","s","e","node","p","wrappedNode","adapters","interfaces","rootInterface","kick","binders","formatters","components","templateDelimiters","binderMap","varBinderMap","preloadData","handler","context","ev","binding","processedArgs","parseFormatterArguments","fnArgs","view","models","fns","this","name","fn","ctx","model","call","fallbackBinder","el","comp","customElements","get","localName","substr","properties","setAttribute","removeAttribute","configure","options","Object","keys","option","key","_this","router","isObject","obj","Observer","keypath","callback","objectPath","parse","getRootObject","target","realize","set","updateOptions","tokenize","chr","current","i","path","charAt","prototype","message","Error","error","pop","prev","token","unreached","splice","sync","next","oldValue","newValue","Function","Array","setValue","active","action","unobserve","rootProp","$parent","parseNode","block","nodeType","data","text","document","createTextNode","parentNode","insertBefore","buildBinding","textBinder","removeChild","traverse","childNodes","bindingComparator","a","b","aPriority","binder","priority","trimStr","str","off","arg","has$","$","removeEventListener","getString","toString","FORMATTER_ARGS","FORMATTER_SPLIT","FN_CHECK","Binding","formatterObservers","subscribers","locked","listeners","observe","parseTarget","fnExpr","map","x","observer","args","formatterIndex","vm","ai","formattedValue","reduce","result","declaration","id","shift","formatter","_this2","read","eventHandler","lfn","constructor","function","routineFn","routine","callSubscribers","publish","reduceRight","_this3","getValue","bind","hasOwnProperty","unbind","fi","_this4","update","checked","selected","subscribe","listener","remove","item","lock","locking","kins","bindings","filter","_this5","kin","mappedType","find","DECLARATION_SPLIT","binderPrefixes","View","els","jquery","build","pipes","forExp","len","elements","sort","binderType","identifier","nodeName","attributes","bindInfos","varBinders","attribute","startWithBinder","attr","bindInfo","_bound","ComponentBinding","publishes","prefix","some","pre","window","jQuery","createView","anchorEl","cloneNode","marker","on","addEventListener","iterated","createComment","collection","modelName","indexProp","getAttribute","matchIndex","nextView","nextIndex","previous","nextSibling","n","cb","times","propertyName","style","elClass","className","replace","textContent","innerHTML","display","disabled","self","isRadio","tagName","event","bound","nested","attached","ARRAY_METHODS","adapter","counter","weakmap","weakReference","defineProperty","__rv","callbacks","cleanupWeakReference","ref","pointers","stubFunction","original","response","apply","observeMutations","unobserveMutations","idx","desc","getOwnPropertyDescriptor","configurable","enumerable","Component","setObservedAttributes","_comp","tag","__templateEl","createElement","propAttributeMap","__propAttributeMap","propName","propConfig","attrName","_HTMLElement","onInit","connectedCallback","nodes","content","__kickView","firstChild","appendChild","afterInit","disconnectedCallback","beforeExit","attributeChangedCallback","old","HTMLElement","watch","not","negate","elm","querySelector","includeFile","viewOptions","extensionType","create","define","init","component","scope","initialize","loadFile","file","xhttp","XMLHttpRequest","onreadystatechange","readyState","status","outerHTML","responseText","responseURL","send","z","elmnt","getElementsByTagName","children"],"mappings":"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"}